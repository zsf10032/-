## 数据结构的基础概念

### 数据（Data）

> 数据是描述客观事物的数值、字符以及能输入机器且能被处理的各种符号集合。

### 数据元素（Data Element）

> 数据元素是组成数据的基本单位,是数据集合的个体，在计算机中通常作为一个整体进行考虑和处理。

### 数据对象（Data Object）

> 数据对象是性质相同的数据元素的集合，是数据的一个子集

### 数据结构（Data Structure）

> 数据结构是指相互之间存在一种或多种特定关系的数据元素集合，是带有结构的数据元素的集合，它指的是数据元素之间的相互关系，即数据的组织形式。一般有：表结构，树形结构，图结构。

### 数据类型（Data Type）

> 数据类型是一组性质相同的值集合以及定义在这个值集合上的一组操作的总称。如在高级语言中，整型类型的取值范围可为:-32767一～+32768，运算符集合为加、减、乘、除、取模，即+、一、*、/、%。

### 抽象数据类型

#### 数据的抽象

汇编语言中十进制表示的数据98.65、9.6E3等，它们是二进制数据的抽象;
高级语言中，给出如整型、实型、字符型等更高一级的数据抽象,还可以进一步定义如各种表、队、栈、树、图、窗口、管理器等复杂的抽象数据类型。

#### 抽象数据类型

抽象数据类型（简称ADT）定义了一个数据对象，数据对象中各元素间的结构关系,以及一组处理数据的操作。
抽象数据类型最重要的特点是 ```数据抽象```  与 ```信息隐蔽```

> 抽象的本质是抽取反映问题本质点，忽视非本质的细节，从而使设计的数据结构更具一般性，可以解决一类问题。
>
> 信息隐蔽就是对用户隐藏数据存储和操作实现的细节，使用者仅需了解操作或界面服务，通过使用界面服务来访问数据

ADT包括 ```定义``` 和 ```实现``` 两方面，其中定义是独立于实现的。

> ADT定义该抽象数据类型需要包含哪些信息，并根据功能确定公共界面的服务，使用者可以使用公共界面中的服务对该抽象数据类型进行操作。
>
> ADT物理实现作为私有部分封装在其实现模块内，使用者不能看到，也不能直接操作该类型所存储的数据，只有通过界面中的服务来访问这些数据。

## 数据结构的内容

### 逻辑结构

> 数据的逻辑结构是指数据元素之间逻辑关系描述。

**<u>形式化描述</u>**:数据结构是一个二元组Data_Structure= (D,R)其中D是数据元素的有限集，R是D上关系的有限集。

e.g.

```c
DS2 = ( D2, R2 )
D2 = { a, b, c, d, e, f }
R2={ T }
T = { <a, b>,<a，c>，<a， d>,<c，e>,<c，f>}
```

#### 四类基本数据结构

##### 集合结构

结构中的数据元素之间除了同属于一个集合的关系外,无任何其他关系。

##### 线性结构

结构中的数据元素之间存在着一对一的线性关系。

##### 树形结构

结构中的数据元素之间存在着一对多的层次关系。

##### 网状结构

结构中的数据元素之间存在着多对多的任意关系。

### 存储结构

> 存储结构(又称物理结构）是逻辑结构在计算机中存储映象，是逻辑结构在计算机中的实现，它包括数据元素的表示和关系的表示。

**<u>形式化描述:</u>**
D要存入机器中，建立一个从D的数据元素到存储空间M单元的映象S，D→M，即对于每一个d，d∈D,都有唯一的z∈M使s (D)=Z，同时这个映象必须明显或隐含地体现关系R。

<u>**逻辑结构与存储结构的关系:**</u>
存储结构是逻辑关系的映象与元素本身映象。逻辑结构是数据结构的抽象，存储结构是数据结构的实现，两者综合起来建立了数据元素之间的结构关系。

**<u>数据元素之间关系在计算机中的表示方法:</u>**
顺序映象（顺序存储结构)
非顺序映象（非顺序存储结构)

### 运算集合

讨论数据结构的目的是为了在计算机中实现操作，因此在结构上的运算集合是很重要的部分。数据结构就是研究一类数据的表示及其相关的运算操作。
通过下面的工资表实例对数据结构的内容作一概括:

```
调入职工时，执行插入操作
调离职工时，执行删除操作
工资变化时，执行更新操作
```

### 小结

综上所述，数据结构的内容可归纳为三个部分逻辑结构、存储结构和运算集合

按某种逻辑关系组织起来的一批数据，按一定的映象方式把它存放在计算机存储器中，并在这些数据上定义了一个运算的集合，就构成数据结构的基本内容。

## 算法

### 算法（Algorithm）定义

> Algorithm is a finite set of rules which gives a sequence of operation for solving a specific type of prob l em.
>
> 算法是规则的有限集合，是为解决特定问题而规定的一系列操作。

### 算法的特性

#### 算法的特性

##### 有限性

有限步骤之内正常结束，不能形成无穷循环

##### 确定性

算法中的每一个步骤必须有确定含义，无二义性

##### 输入

有多个或0个输入

##### 输出

至少有一个或多个输出
原则上能精确进行，操作可通过已实现的基本运算执行有限次而完成

##### 可行性

至少有一个或多个输出
原则上能精确进行，操作可通过已实现的基本运算执行有限次而完成

### 算法设计的要求

算法设计的要求
1)算法的正确性

```
“正确”的含义大体上可以分为三个层次:1．所设计的程序对于几组输入数据能
够得出满足要求的结果;
2.所设计的程序对于精心选择的典型、
苛刻而带有刁难性的几组输入数据能够得到满足要求的结果;
3.程序对于一切合法的输入数据都能
产生满足要求的结果。
```

2)可读性

```
一个好的算法首先应该便于人们理解和相互交流，其次才是机器可执行。可读性好的算法有助于人对算法的理解，难懂的算法易于隐藏错误且难于调试和修改。
```

3)健壮性（鲁棒性)

``` 
即对非法输入的抵抗能力。它强调即使输入非法数据，算法应能加以识别并作出处理，而不是产生误动作或陷入瘫痪。
```

4)高效率和低存储量

```
算法的效率通常是指算法的执行时间。对于一个具体的问题的解决通常可以有多个算法，对于执行时间短的算法其效率就高。
所谓的存储量需求,是指算法在执行过程中所需要的最大存储空间,这两者都与问题的规模有关。
```



## 算法描述

概述:算法+数据结构=程序

### 算法、语言、程序的关系

**<u>算法:</u>**规则的有限集合，是为解决特定问题而规定的一系列操作。
<u>**描述算法的工具:**</u>算法可用自然语言、框图或高级程序设计语言进行描述。
<u>**程序:**</u>是算法在计算机中的实现。

### 设计实现算法过程步骤

```
找出与求解有关的数据元素之间的关系
确定在某一数据对象上所施加运算
考虑数据元素的存储表示
选择描述算法的语言
设计实现求解的算法，并用程序语言加以描述
```

### 类描述算法的语言选择

类语言:

> 类语言接近于高级语言而又不是严格的高级语言。
> 具有高级语言的一般语句规格，撇掉语言中的细节，把注意力主要集中在算法处理步骤本身的描述上。

## 算法作性能评价

评价算法的标准
评价算法性能的标准主要从算法执行时间与占用存储空间两方面考虑，即算法执行所需的时间和存储空间来判断一个算法的优劣。

### 性能评价

定义:

> 算法所占用机器资源主要表现在时间代价和空间代价两个方面。算法效率与问题规模N有关,算法效率应是问题规模的函数。

问题规模N:

反映问题大小的本质数目，对于不同的问题其含义不同:

> 对矩阵是阶数;
> 对多项式运算是多项式项数;对图是顶点个数;
> 对集合运算是集合中的元素个数...

### 有关数量关系计算

数量关系评价可以体现在 ```时间``` 和 ```空间``` 上。

> 算法编程后在机器中运行所耗费的时间
>
> 算法编程后在机器中运行所占的存储量

#### 关于算法执行时间

定义:

算法执行时间=其所有语句执行时间的总和

语句执行时间=该条语句的执行次数*执行1次所需时间

分析:

由于算法的实际执行时间与机器硬件和系统软件等多种环境因素有关，因此算法的执行时间是针对算法中语句的执行次数做出估计，从中得到算法执行时间的本质信息。

#### 语句频度

定义:语句频度是指该语句在一个算法中重复执行的次数。

例如:两个n×n矩阵相乘

``` c
算法语句							对应的语句频度
1 for (i=0; i< n;i++)					n
2 for (j=0; j<n;j++)					n^2
3 {c[i][j]=0;						    n^2
4 for (k=0;k< n; k++){					n^3
	c[i][j]=c[i][j]+a[i][k]*b[k][j];	 n^3
	}
```


总执行次数:f(n)=2n^3 +2n^2 +n

#### 算法的时间复杂度

**<u>定义:</u>**即算法的时间量度，以语句频度为量度。记作:T(n)=O(f (n))
例,给出x=x+1的时间复杂度分析。
(1）x=x+1 ;时间复杂度为0(1)，称为常数阶;

(2) for (i=1; i<= n; i++) x=x+1;时间复杂度为0(n)，称为线性阶;

(3)for (i=1 ; i<=n; i++)
	for(j=1 ; j<=n; j++)
	x=x+1;
	时间复杂度为0(n^2),称为平方阶。

#### 数据结构中常用的时间复杂度频率计数

数据结构中常用的时间复杂度频率计数有7个:

0(1)					常数型
0(n)				    线性型
0(n^2)				  平方型
0(n^3)				  立方型
0(2)					指数型
0( log2n)			对数型
0(nlog2n)		   二维型

#### 最坏时间复杂度

**<u>定义:</u>**讨论算法在最坏情况下的时间复杂度，即分析最坏情况下以估计出算法执行时间的上界。

```c
void bubble (int a[]，int length)
{ 
    int i=0, j, temp ;
    int change ;
    do {
        change=false ;
        for(j=1 ;j<length-i ; j++)if( a[j]>a[j+1])
        	{
                temp= a[j];a[j]=a[j+1];
                a[j+1]=temp;change=true;
            }
        i=i+1;
        }
    while(i<length ll change==true)
}
```

**<u>分析:</u>**

“交换序列中相邻的两个整数”为基本操作。
n为length,当a中初始序列为自小到大有序，基本操作的执行次数为0;
当初始序列为自大到小有序时，基本操作的执行次数为n (n-1)/2。
气泡排序在最坏情况下的时间复杂度就为T(n)=O(n^2)。

#### 算法的空间复杂度

**<u>定义:</u>**
用空间复杂度作为算法所需存储空间的量度，按存储空间个数计算。
记做:S(n)=O(f(n))。

## 结构化程序设计与函数的模块化结构化程序设计概述

著名的计算机科学家wirth(沃思)提出了一个著名的公式表达了程序设计的实质:

> 算法+数据结构=程序。

即“程序是在数据的特定表示方式的基础上，对抽象算法的具体描述”

> 程序结构=控制结构+数据结构

结构化程序设计是为使程序具有合理的结构,以保证程序正确性而规定的一套程序设计的方法，是人们多年来研究与实践的结晶。

结构化程序设计的**<u>目的</u>**:

通过设计结构良好的程序，以程序的静态良好结构保证程序动态执行的正确性，使程序易理解、易调试、易维护，以提高软件开发的效率，减少出错率。

### 结构化程序设计的构成单元

任何程序都可由顺序选择重复三种基本控制结构来组成

### 限制GOTO语句的意义

goto 语句为无条件转向语句，其一般格式为:goto 语句标号

含义是无条件跳转到语句标号所处位置开始继续执行后面的语句。显然goto语句改变了程序的执行顺序。如果程序中不限制goto 语句的使用,则使得程序的静态结构与程序的动态执行差异很大,程序难阅读、难理解，破坏了单入口/单出口的原则，使程序的正确性难以证明，错误难以局部化。

### 结构化程序设计方法

#### 其一是“自顶向下，逐步求精”的设计思想

即整个设计应分为若干层次，逐步加以解决;而每一步实在前一步的基础上，对前一步设计的细化。

#### 其二是“独立功能，一个入口，一个出口“的模块化结构

即把大而复杂的问题层层细化分解成若干个相对独立、功能单一的问题处理模块，而每个模块与外界联系只有一个入口与出口。

#### 其三是“仅用三种基本控制结构”的设计原则

即每个模块都只用三个基本结构来描述

### 用C语言实现的抽象数据类型ADT

### **ADT的定义格式**

ADT包括对象、关系、操作三个部分，其定义格式有多种,我们采用下述格式定义ADT :

```c
ADT<ADT名>
	{数据对象:<数据对象的定义>
	 结构关系:<结构关系的定义>
	 基本操作:<基本操作的定义>
	}ADT<ADT名>
```

其中:

- 数据对象定义应在已有数据类型或已定义数据对象基础上对新的数据
  对象的定义。

- 数据对象和结构关系的定义采用数学符号和自然语言描述。

- 基本操作定义包括操作名称、参数表、初始条件和操作结果4部分内
  容的定义和描述。

  

  基本操作的定义格式为:
  	<操作名称>（参数表)
  	操作前提:<操作前提描述>
  	操作结果:<操作结果描述>

例:

给出一个线性表的抽象数据类型的描述ADT Linear_list
数据元素	所有ai属于一数据对象，
$$
i=1，2,…, n n≥0
$$
逻辑结构	所有数据元素
$$
ai ( i=1,2,… , n-1)
$$
存在次序关系<ai, ai+1>,a1无前趋，an无后继

操作

设L为Linear_list :

```
lnitList (L):初始化空线性表

ListLength(L):求线性表的长度

GetData (L,i):取线性表的第i个元素

lnsList(L，i , b):在线性表的第i个位置插入元素b

DelList(L,i):删除线性表的第i个元素。
```

用C语言实现ADT时，主要包括以下两个方面
(1)通用结构体将int、float等固有类型组合到一起，构成一个结构体类型，再用typedef为该类型或该类型指针重新起一个名字，以便增强程序的抽象性、简洁性和可读性。即采用C语言中typedef自定义类型来实现。

(2)用C语言的子函数实现各个操作。

typedef可以用来建立已定义好的数据类型的别名。为建立较短、便于记忆和使用的类型名，为了省略结构标记，C程序员经常使用typedef定义结构类型。如typedef struct card Card;建立用户自定义的数据类型的新类型名为Card，它是类型struct card的别名。就可以利用Card类型名来代替struct card类型名。如下例:

```
typedef struct node//结点类型定义
{
    char Name[20];
    char Sex;
    int Age;
    float Money;
}Employee,*EmpPtr ;
```

## 算法描述规范与设计风格

### 算法描述方法

```
[函数返回值类型]函数名([形式参数及说明])
{
    内部数据说明;
    执行语句组;
}/*函数名*/
```



### 完整C程序的结构

C的函数相当于其它语言中的子程序。用函数来实现特定的功能。—个完整的、可执行的c程序文件一般结构如下:

```c
[包含文件语句]		 #inlcude
[宏定义语句]			  #define
首定义类型语句]		typedef

[所有子函数的原型说明]

[子函数1定义]
type_1 fun_1(参数表1){...}

[子函数n定义]
type_n fun_n(参数表n{...}

[主函数定义]
main( ){...}
```

### 算法描述要点

- 加上必要的注释
- 避免函数返回值隐含说明
- 预定义常量和类型
- 使用有意义的函数名与变量名
- 避免可能出现的二义性表达
- 规范多分支转向
- 简化输入、输出表述
- 注意不同的退出语句区别

### 变量的作用域

**全局变量**:程序中所有函数都可以访问的量。

**局部变量**:只能在该函数中访问的量。

### 参数传递方式

参数传递是函数之间进行信息通讯的重要渠道。其参数传递的主要方式有传值和传地址两类。

值传递:C语言中调用函数时，实参代替形参的过程是一个单向的传值过程，在编译技术中称为值传递方式。
传地址:C语言中指针类型的参数传递可以看作是传地址方式。

### 函数结果的带出方式

函数结果共有全程量、函数返回值、传址参数三种带出方式。
值传递方式中，如果返回一个结果值，可以使用return方式返回方式带出一个函数结果值。若函数结果需要带出多个值，该怎样实现?

#### 全局变量方式

```c
int fun1 (int a[]， int n)
/*通过函数return返回最大值，通过全局变量MIN带回最小值*/
{ 
    int i , max;
    /*给最大值最小值赋初值*/
    max=MIN=a[O];
    for (i=O; i<n;i++)
    {
    	if(a[i]>max)max=a[i];
    	if (a[i]<MIN) MIN=a[i];
    }
    return (max) ;
}


```



####  数组方式

```c
int *fun2 (int a[],int n)
/*将最大、最小值放到数组b中，通过return返回*/
{ 
    static int b[2];b[0]=b[1]=a[0] ;int i;
    for (i=1 ; i<n ;i++){
        if (a[i]>b[0])
            {
            b[0]=a[i];
            };
        if (a[i]<b[1])
            {
            b[1]=a[i];
            };
    }
    return(b);
}
```

如果要返回的是多个相同类型的值，则可以将这些值放到一个数组中,然后返回数组的指针或首地址（如源程序中fun2()函数的数组b,带出2个值)

#### 结构体方式

```c
Data *fun3(int a[],int n)
/*将最大、最小值放到结构体指针p中,通过return返回*/
{ 
    Data *p;
    int i ;
    p=(Data *)malloc(sizeof(Data *));
    p->max=p->min=a[o];
    for (i=1 ; i<n;i++)
    { 
        if (a[i]>p->max)
            {
            p->max=a[i];
            };
        if (a[i]<p->min)
            {
            p->min=a[i];
            };
    }
    return(p);
}
```

```c
Data fun4(int a[],int n)
/*将最大、最小值放到结构体p中，通过结构体p带回返回值*/
{
    Data p;
    int i;
    p.max=p.min=a[O];
    for( i=1 ; i<n; i++)
    {
        if (a[i]>p. max)
            {
                p.max=a[i];
            };
        if (a[i]<p.min)
            {
                p.min=a[i]
            };
    }
    return (p);
}
```

如果要返回的是多个不同类型的值，则可以将这些值放到一个结构体当中，然后返回结构体的指针或全局变量，但必须注意的是该结构体必须是在全局范围内定义的结构体。

#### 指针方式

```c
void fun5(int a[],int n,int *p,int *q)
/*用指针带回返回值，指针p指向最大值，指针q指向最小值*/
{
    int i;
    *p=*q=a[0] ;
    for ( i=1 ; i<n ; i++)
    {
        if(*p<a[i])
            {
                *p=a[i];
            }
        if(*q>a[i])
            {
                *q=a[i];
            }
	}
}
```

如源程序中的fun5(函数中指针x指向最大值，指针y指向最值，通过地址这是一种参数显式传递方式。

```c
void main()
{ 
    int a[10]={1,3,9，8，4,2,5,0，7,6]} , max，*p ;
    Data *q;
    Data z;
    int *x，*y;
    x=(int *)malloc(sizeof (int*));
    y=(int *)malloc(sizeof (int *));
    
    /*全局变量方式*/
    max=fun1(a,10) ;
    printf ("max=%dmin=%d \n" , max,MIN);
    
    /*数组方式*/
    p=fun2(a,10);
    printf ("max=%dmin=%d \n", p[0],p[1]);
	
	/*结构体方式*/
    q=fun3(a,10);
    printf (" max=%dmin=%d\n" , q->max, q->min);
    
    /*结构体方式*/
    z=fun4(a,10);
    printf("max=%dmin=%d\n",z.max,z.min) ;
    
    /*指针方式*/
    fun5(a，10，x,y);
    printf ("max=%dmin=%d \n"，*x，*y);
}
```

### 面向对象与抽象数据类型

> 面向对象的概念面向对象=对象+类+继承+通信

**<u>对象:</u>**是指在应用问题中出现的各种实体、事件和规格说明等，它是由一组属性和在这组值上的一组服务构成的，其中属性值确定了对象的状态。

**<u>类:</u>**把具有相同属性和服务的对象归到同一类,而把一个类中的每一个对象称为该类的一个实例,它们具有相同的服务。

**<u>继承:</u>**面向对象方法的最有特色的方面。

面向对象程序设计的特点是封装性（encapsulation）、继承性(inheritance)和多态性(polymorphism)。

**<u>基本操作:</u>**

1. 插入:在数据结构中的指定位置上增添新的数据元素;
2. 删除:删去数据结构中某个指定数据元素﹔
3. 更新:改变数据结构中某个元素的值，在概念上等价于删除和插入操作的组合﹔
4. 查找:在数据结构中寻找满足某个特定要求的数据元素（的位置和值）﹔
5. 排序:（在线性结构中）重新安排数据元素之间的逻辑顺序关系，使数据元素按值由小到大或由大到小的次序排列。

#### 结构化的开发方法

结构化的开发方法是面向过程的开发方法，首先着眼于系统要实现的功能。从系统的输入和输出出发，分析系统要实现的功能，用自顶向下、逐步细化的方式建立系统的功能结构和相应的程序模块结构。一旦程序功能需要修改，就会涉及多个模块，修改量大，易于出错，并会引起程序的退化。

#### 面向对象的方法

面向对象的方法首先着眼于应用问题所涉及的对象，包括对象、对象属性、要求的操作，从而建立对象结构和为解决问题需要执行的时间序列，据此建立类的继承层次结构，通过各个类的实例之间的消息连接实现所需的功能。类的定义充分体现了抽象数据类型的思想，基于类的体系结构可以把对程序的修改局部化，如果系统功能的需求发生变化，只需修改类中间的服务即可，此时类所代表的对象基本不变，从而确保系统不致因修改而退化。

#### 不同点

由于用面向对象开发方法建立起来的软件易于修改，与传统方法相比，程序具有更高的可靠性、可修改性、可维护性、可复用性、可适用性和可理解性。

#### 抽象数据类型与问题求解方法

程序设计中一些最基本的原则:分解、抽象和信息隐藏。

一个抽象数据类型确定了一个模型，但将模型的实现细节隐藏起来;它定义了一组运算，但将运算的实现过程隐藏起来。

用抽象数据类型的概念来指导问题求解的过程。

| 数学模型   | 抽象数据类型 | 数据结构   |
| ---------- | ------------ | ---------- |
| 非形式算法 | 伪语言程序   | 可执行程序 |

- 第一步是选用适当的数学模型来描述要处理的问题，与此同时确定解决问题的算法的基本思想。
- 第二步是用一种比较形式的方法将解决问题的算法表达出来。描述算法的工具可以采用一种类语言（比如说类似C的语言)
- 第三步是对每个抽象数据类型选择一种实现的方法，同时编写出这些抽象数据类型上定义的所有操作的过程。

#### 抽象数据类型实现的途径三种情况

第一种:传统的面向过程的程序设计。
第二种情况:“包”、“模型”的设计方法。
第三种情况:面向对象的程序设计(Object Oriented Programming, OOP)



___

# 线性表

## 线性表的概念及抽象数据类型定义

### 线性表的逻辑结构

#### 线性表的定义

线性表是n个类型相同的数据元素的有限序列，对n>0,除第元素无直接前驱、最后一个元素无直接后继外,其余
的每个数据元素只有一个直接前驱和一个直接后继。

#### 线性表的特点

**<u>同一性:</u>**线性表由同类数据元素组成,每一个ai必须属于同一数据对象。

有穷性:线性表由有限个数据元素组成,表长度就是表中数据元素的个数。

有序性:线性表中相邻数据元素之间存在着序偶关系<ai,ai+1>

### 线性表的抽象数据类型定义

**<u>抽象数据类型定义:</u>**
ADT LinearList {

数据元素:D={ail a; ∈DO,i=1,2,…，n n≥0 ，D0为某一数据对象}

结构关系:S= {<ai, ai+1>\ ai,ai+1∈DO，i=1,2,…, n-1 }

基本操作:

( 1) lnitList (L）		操作前提:L为未初始化线性表。
								操作结果:将L初始化为空表。
(2) DestroyList (L)	操作前提:线性表L已存在
								操作结果:将L销毁。
(3)ClearList (L)		操作前提:线性表L已存在
								操作结果:将表L置为空表

(4)EmptyList(L)		操作前提:线性表L已存在。
								操作结果:如果L为空表则返回真，否则为假。

(5)ListLength(L)		操作前提:线性表L已存在。
								操作结果:如果L为空表则返回0，否则返回表中元素个数。

(6)Localte(L,e)		操作前提:表L已存在，e为合法元素值。
								操作结果:如果L中存在元素e，则将“当前指针”指向元素e所在位置并返回真，否则返回假。
(7)GetData(L,i)		操作前提:表L存在，且i值合法，即1≤i≤Listlength(L).

​								操作结果:返回线性表L中第i个元素的值。
(8)InsList(L,i,e)		操作前提:表L已存在，e为合法元素且1SisListlength(L)+1

​								操作结果:在L中第i个位置插入新的数据元素e，L的长度加1

(9)DelList(L,i,&e)	操作前提:表L已存在且非空，1si≤Listlength(L).
								操作结果:删除L的第i个数据元素，并用e返回其值，L的长度减1。

}ADT LinearList

## 线性表的顺序存储

### 线性表的顺序存储结构

#### 顺序存储结构的定义

<u>**线性表的顺序存储**</u>是指用一组地址连续的存储单元依次存储线性表中的各个元素，使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。采用顺序存储结构的线性表通常称为**<u>顺序表</u>**。
将顺序表归纳为:关系线性化，结点顺序存。
假设线性表中有n个元素，每个元素占k个单元，第一个元素的地址为loc(a1)，则可通过如下公式计算出第i个元素的地址Loc(ai) :
loc(ai) =loc(a1)+(i-1)×k
其中loc(a1)称为基地址.

#### 顺序存储结构的C语言定义

```c
#define MAXSIZE 100

typedef struct
{ 
    ElemType elem[MAXSIZE];
    int last;
}SeqList;
/*注意区分元素的序号和数组的下标，如a1的序号为1，而其对应的数组下标为0。*/
```

### 线性表顺序存储结构上的基本运算

#### 查找操作

- 1.按序号查找GetData(L,i):要求查找线性表L中第i个数据元素，其结果是L.elem[i-1]或L->elem[i-1]。
- 2.按内容查找Locate (L, e）:要求查找线性表L中与给定值e相等的数据元素，其结果是:若在表L中找到与e相等的元素，则返回该元素在表中的序号;若找不到,则返回一个“空序号”，如-1。

```c
int Locate (SeqList L，ElemType e)
/*在顺序表L中依次存放着线性表中的元素，在表中查找与e相等的元素，若L[i]=e则找到该元素，并返回i值，若找不到，则返回"-1"*/
{
    i=0 ;										/*i为扫描计数器，初值为0，即从第一个元素开始比较*/
    while (( i<=L.last)&& (L.elem[i]!=e))
    	i++;
    											/*顺序扫描表，直到找到值为key的元素，或扫描到表尾而没找到*/
    if(i<=L.last)
    	return(i+1);
   												 /*若找到值为e的元素，则返回其序号*/
    else
    	return(-1);									/*若没找到，则返回空序号*/
}
```

<movie></movie>

#### 插入操作

线性表的插入运算是指在表的第i(1≤in+1)个位置，插入一个新元素e，使长度为n的线性表 
$$
(e_i,\cdots,e_{i-1},e_i,\cdots,e_n)
$$
 变成长度为n+1的线性表
$$
(e_i,\cdots,e_{i-1},e_i,\cdots,e_{n+1})
$$
线性表(4,9,15,28,30,30,42,51,62),需在第4个元素之前插入一个元素”21”.需要将第9个位置到第4个位置的元素依次后移一个位置,然后将“21”插入到第4个位置

```c
int InsList(SeqList *L,int i,ElemType e)
/*在顺序表L中第i个数据元素之前插人一个元素e。表长n=L->last+1，i的合法取值范围是1sisL->last+2 */
{
    int k;
    if((i<1)1l(i>L->last+2))				/*首先判断插人位置是否合法*/
    {
        printf("插入位置i值不合法");
        return(ERROR);
    }
    if(L->last>=maxsize-1)
    {
        printf("表已满无法插入");
        return(ERROR);
    }
    for(k=L->last;k>=i-1;k--)
                                       /*为插人元素而移动位置*/
    	L->elem[k+1]=L->elem[k];
    L->elem[i-1]=e;
    /*在C语言数组中，第i个元素的下标为i-1*/
    L->last++;
    Return(OK);
}
```

<movie></movie>

#### 删除操作

线性表的删除运算是指将表的第i(1<i≤n)
个元素删去，使长度为n的线性表变成长度为n-1的线性表
$$
(e_i,\cdots,e_{i-1},e_i,\cdots,e_{n-1})
$$

```c
int DelList(SeqList *L,int i,ElemType *e)			/*在顺序表L中删除第i个数据元素，并用指针参数e返回其值。i的合法取值为1≤isL.last+1 */
{ 
    int k;
    if((i<1)||(i>L->last+1))
    {
        printf(删除位置不合法!");
        return(ERROR);
    }
    *e= L->elem[i-1];
    /*将删除的元素存放到e所指向的变量中。*/
    for(k=i;k<=L->last;k++)
        L->elem[k-1]= L->elem[k];					/*将后面的元素依次前移*/
    L->last--;
    Return(OK);
}
```

<movie></movie>

#### 顺序表合并算法

已知:

有两个顺序表LA和LB，其元素均为非递减有序排列，编写一个算法，将它们合并成一个顺序表LC，要求LC也是非递减有序排列。

算法思想:
设表LC是一个空表，为使LC也是非递减有序排列，可设两个指针i、j分别指向表LA和LB中的元素，LA.elem[i]>LB.elem[j]，则当前先将LB.elem[j]插入到表LC中,LA.elem[i]≤LB.elem[j]，当前先将LA.elem[i]插入到表LC中，如此进行下去，直到其中一个表被扫描完毕,然后再将未扫描完的表中剩余的所有元素放到表LC中。

```c
void merge(SeqList *LA,SeqList*LB,SeqList *LC)
{ int i,j,k,l;i=0;j=0;k=0;
	while(i<=LA->last&&j<=LB->last)
        if(LA->elem[i]<=LB->elem[j])
            {
                LC->elem[k]= LA->elem[i];
                i++; k++;
            }
        else {
                LC->elem[k]=LB->elem[j];
                j++; k++;
            }
	while(i<=LA->last)					/*当表LA比表LB长时，则将表LA余下的元素赋给表LC*/
		{
            LC->elem[k]=LA->elem[i];
            i++; k++;
		}
	while(j<=LB->last)					/*当表LB比表LA长时，则将表LB余下的元素赋给表LC*/
        {
            LC->elem[k]= LB->elem[j];
            j++; k++;
        }
	LC->last=LA->last+LB->last+1;
}
```

### 线性表顺序存储结构的优缺点分析

> 优点:

- 无需为表示结点间的逻辑关系而增加额外的存储空间。
- 可方便地随机存取表中的任一元素。

> 缺点:

- 插入或删除运算不方便，除表尾的位置外，在表的其它位置上进行插入或删除操作都必须移动大量的结点，其效率较低。
- 由于顺序表要求占用连续的存储空间，存储分配只能预先进行**静态分配**。因此当表长变化较大时，难以确定合适的存储规模。

## 线性表的链式存储

**<u>链表定义:</u>**

> 采用链式存储结构的线性表称为链表

我们从两个角度来讨论链表:

1. 从实现角度看，链表可分为动态链表和静态链表;
2. 从链接方式的角度看，链表可分为单链表、循环链表和双链表。

### 单链表

**<u>结点:</u>**存储线性表的每个数据元素值的信息与元素间逻辑关系即后继结点地址信息的两部分存储映象
**<u>单链表</u>**:每个结点只有一个指针域的链表。包括数据域和指针域
**<u>数据域:</u>**存储结点的值
<u>**指针域**:</u>存储数据元素的直接后继的地址
**<u>头指针:</u>**指向链表头结点的指针。

单链表的存储结构描述

```c
typedef struct Node
{
    ElemType data;
    struct Node*next;
} Node，*LinkLi st;
```

### 单链表上的基本运算

#### 建立单链表

#####  头插法建表

算法描述:从一个空表开始，重复读入数据，生成新结点，将读入数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头结点之后，直至读入结束标志为止。

```c
Linklist CreateFromHead(LinkList L)
{
    LinkList L;
    Node *s;
    char c;
    int flag=1;
    									/*设置一个标志，初值为1，当输人"$"时，flag为0，建表结束*/
    while(flag)
    	{c=getchar();
    		if(c!='$')
    			{
                    s=(Node*)malloc(sizeof(Node));			/*为读入的字符分配存储空间*/
                    s->data=c;
                    s->next=L->next;L->next=s;
    			}
             else flag=0;
         }
}
```

##### 尾插法建表

```c
Linklist CreateFromTail(LinkList L)
{
	LinkList L; Node *r, *s;
	int flag =1;					/*设置一个标志，初值为1，当输入"$"时，flag为0，建表结束*/
	r=L;				/*r指针始终动态指向链表的当前表尾，以便于做尾插入，其初值指向头结点*/
	while(flag)
		{
		c=getchar();
		if(c!='$')
			{
                s=(Node*)malloc(sizeof(Node));
                s->data=c;
                r->next=s;
                r=s;
			}
		else {
                flag=0;
                r->next=NULL;					/*将最后一个结点的next链域置为空，表示链表的结束*/
			}					
		}
}

```



#### 单链表查找

##### 按序号查找

算法描述:设带头结点的里进衣的长屋E出君从表中第i个结点，则需要从单链表的头指针L出发，从头结点(L->next）开始顺着链域扫描，用指针p指向当前扫描到的结点,初值指向头结点（pL->next) ，用j做记数器，累计当前扫描过的结点数(初值为0），当j=i时，指针p所指的结点就是要找的第i个结点。

```c
Node * Get (LinkList L, int i)
{											/*在带头结点的单链表L中查找第i个结点，若找到(1≤i≤n)，则返回该结点的存储位置;否则返回NULL*/
	int j;
	Node *p;
	p=L; j=0;										/*从头结点开始扫描*/
	while ((p->next!=NULL)&&(j<i))
	{
		p=p->next;						/*扫描下一结点*/j++;*已扫描结点计数器*l/
	}
	if(i==j)
		return p;					/*找到了第i个结点*l/
	else 
		return NULL;
									/*找不到，i≤0或i>n */
}
```

##### 按值查找

算法描述:按值查找是指在单链表中查找是否有结点值等于e的结点，若有的话，则返回首次找到的其值为e的结点的存储位置，否则返回NULL。查找过程从单链表的头指针指向的头结点出发，顺着链逐个将结点的值和给定值e作比较。

```c
Node *Locate(LinkList L,ElemType key)
{

Node *p					/*在带头结点的单链表L中查找其结点值等于key的结点，若找到则返回该结点的位置p，否则返回NULL */
p=L->next;				/*从表中第一个结点比较*/
while (p!=NULL)
if (p->data!=key)
	p=p->next;
else 
	break;				/*找到结点key，退出循环*/						
return p;
}
```

#### 单链表插入

算法描述:

要在带头结点的单链表L中第i个数据元素之前插入一个数据元素e，需要首先在单链表中找到第i-1个结点并由指针pre指示，然后申请一个新的结点并由指针s指示，其数据域的值为e，并修改第i-1个结点的指针使其指向s，然后使s结点的指针域指向第i个结点。

```c
void InsList(LinkList L,int i,ElemType e)
{
    Node *pre,*s;
    int k;
    pre=L; k=o;
    while(pre!=NULL&&k<i-1)					/*在第i个元素之前插人，则先找到第i-1个数据元素的存储位置,使指针Pre指向它*/
        {
            pre=pre->next;
            k=k+1;
        }
    if(!pre)								/*如当前位置pre为空，表示已找完还未数到第i个，说明插人位置不合理*/
        {
            printf("插入位置不合理! ");
            return ERROR;
        }
    s=(Node*)malloc(sizeof(Node));				/*为e申请一个新的结点并由S指向它*/
    s->data=e;									/*将待插人结点的值e赋给s的数据域*/
}
```

#### 单链表删除

算法描述:

欲在带头结点的单链表L中删除第i个结点，则首先要通过计数方式找到第i-1个结点并使p指向第i-1个结点，而后删除第i个结点并释放结点空间。

```c
void DelList(LinkList L,int i,ElemType *e)					/*在带头结点的单链表L中删除第i个元素，并将删除的元素保存到变量*e中。*/ 
{
	Node *p,*r;
    int k;
    p=L;k=0;
    while(p->next!=NULL&&k<i-1)								
    {
        p=p->next;											/*寻找被删除结点i的前驱结点i-1使p指向它*/
        k=k+1;
	}
	if(k!=i-1)												/*即while循环是因为p->next=NULL而跳出的*/
        {
            printf("删除结点的位置i不合理! ");
            return;
        }
	r=p->next;
	p->next=p->next->next;
	*e=r->data;
	free(r);/*释放被删除的结点所占的内存空间*/
}
```

### 算法应用示例

#### 求单链表的长度

算法描述:

可以采用“数”结点的方法来求出单链表的长度，用指针p依次指向各个结点,从第一个元素开始“数”,一直“数”到最后一个结点(p->next=NULL) 。

```c
int ListLength(LinkList L)
/*本算法用来求带头结点的单链表L的单链表的长度*/
{
    Node *p;
    p=L->next;
    j=o;				/*用来存放单链表的长度*/
    while(p!=NULL)
        {
        p=p->next;
        j++;
        }
    return j;
}
```

#### 求两个集合的差

已知:

以单链表表示集合，假设集合A用单链表LA表示，集合B用单链表LB表示，设计算法求两个集合的差，即A-B。

算法思想:

由集合运算的规则可知，集合的差A-B中包含所有属于集合A而不属于集合B的元素。具体做法是，对于集合A中的每个元素e，在集合B的链表LB中进行查找，若存在与e相同的元素，则从LA中将其删除。

```c
void Difference(LinkList LA,LinkList LB)
{
    Node *pre;*p,*q,*r;
    pre=LA;
    p=LA->next;
    while(p!=NULL)
    {
        q=LB->next;
        while(q!=NULL&&q->data!=p->data)
        	q=q->next;
    	if (q=NULL)
    		{
                r=p;
                pre->next=p->next;
                p=p->next;
                free(r);
    		}
    	else
    		{
    			pre=p;
    		p=p->next;
    		}
    }
}
```

### 循环链表

循环链表(Circular Linked List)是一个首尾相接的链表。

特点:将单链表最后一个结点的指针域由NULL改为指向头结点或线性表中的第一个结点，就得到了单链形式的循环链表，并称为循环单链表。在循环单链表中，表中所有结点被链在一个环上。



#### 循环单链表的合并算法

已知:有两个带头结点的循环单链表LA、LB，编写一个算法，将两个循环单链表合并为一个循环单链表，其头指针为LA。

算法思想:
先找到两个链表的尾,并分别由指针p、q指向它们，然后将第一个链表的展与第二个衣的弟二约点链接起来，并修改第二个表的尾Q，使它的链域指向第一个表的头结点。

```c
LinkList merge_1(LinkList LA,LinkList LB)
{
    Node *p,*q;
    p=LA;
    q=LB;
    while (p->next!=LA)p=p->next;while (q->next!=LB)q=q->next;q->next=LA;
    p->next=LB->next;free(LB);
    return(LA);
}
```

```c
LinkList merge_2(LinkList RA,LinkList RB)
{
    Node *p;
    p=RA->next;
    RA->next=RB->next->next;
    free(RB->next);
    RB->next=p;return RB;
}
```

### 双向链表

双向链表:给单链表的每个结点增加一个指向其前趋的指针后的新链表。

> 前驱指针—>数据域—>后继指针

其结构定义:

```c
typedef struct Dnode
{
    ElemType data;
    struct DNode *prior，*next;
}DNode,*DoubleList;
```

#### 前插操作演示

```c
void DlinkIns(DoubleList L,int i,ElemType e)
{
    DNode *s,*p;									/*首先检查待插入的位置i是否合法(实现方法同单链表的前插操作)*/		
                                                            /*若位置i合法，则让指针p指向它*/
    s=(DNode*)malloc(sizeof(DNode));
    if (s)
        {
            s->data=e;
            s->prior=p->prior;
            p->prior->next=s;
            s->next=p;
            p->prior=s;
            return TRUE;
        }
    else 
        return FALSE;
}

```

#### 删除操作演示

```c
int DlinkDel(DoubleList L,int i,ElemType *e)
{
    DNode *p;						/*首先检查待插入的位置i是否合法(实现方法同单链表的删除操作)*/
                                            /*若位置i合法，则让指针p指向它*l/
    *e=p->data;
    p->prior->next=p->next;
    p->next->prior=p->prior;
    free(p);
    return TRUE;
}
```

#### 应用举例

已知:

设一个循环双链表L= (a, b, c, d)编写一个算法将链表转换为L= (b, a,c, d)

算法思想:实际上是交换表中前两个元素的次序。

```c
void swap(DLinkList L)
{
    DNode * p,*q,*h;h=L->next;			/*h指向表中的第一个结点，即a */
    p=h->next;						/*p指向b结点*/
    q=h->prior;							/*保存a结点的前驱*/
    h->next=p->next;					/*a结点的后继指向c结点*/
    p->next->prior=h;					/*c结点的前驱指向a结点*/
    p->prior=q;							/*将b结点插入，作为表的第一个结点*/
    p->next=h;							/*b结点的后继指向a结点*/
    h->prior=p;							/*a结点的前驱指向b结点*/
    L->next=p;							/*将表的头结点的next域指向b结点*/
}
```



### *静态链表

## 一元多项式的表示及相加

### 表示方式

一个一元多项式Pn(x)可按升幂的形式写成:
$$
Pn(x)=p_0+p_1x+p_2x^2+p_3x^3+ \cdots +p_nx^n
$$
在计算机内，可以用一个线性表P来表示:
$$
P=(p_0,p_1,p_2，\cdots，p_n）
$$


### 顺序存储结构

- 只存储各项的系数，存储位置下标对应其指数项
  →适于非零系数多的多项式
- 系数与指数均存入顺序表
  →适于零项很多，且指数较大

### 链式存储结构

用单链表存储多项式的结点结构如下:

```c
typedef struct Polynode
{
    int coef;
    int exp;
    Polynode *next;
} Polynode , *Polylist;
```

系数—>指数—>指向下一节点

```c
Polylist polycreate()
{ 
    Polynode *head, *rear,*s;int c,e;
    (Polynode *)malloc(sizeof(Polynode));						/*建立多项式的头结点*/
    rear=head;											/*rear始终指向单链表的尾，便于尾插法建表*/
    scanf("%d,%d",&c,&e);									/*键入多项式的系数和指数项*/
    while(c!=0)											/*若c=0，则代表多项式的输入结束*/
        {
            s=(Polynode*)malloc(sizeof(Polynode));					/*申请新的结点*/
            s->coef=c ;
            s->exp=e ;
            rear->next=s ;										/*在当前表尾做插入*/
            rear=s;
            scanf( "%d,%od",&c,&e);
        }
    rear->next=NULL;								/*将表的最后一个结点的next置NULL，以示表结束*/
    return(head);
}
```

## 顺序表与链表的综合比较

### 顺序表和链表的比较

#### 基于空间的考虑

顺序表的存储空间是静态分配的，在程序执行之前必须明确规定它的存储规模。在静态链表中，初始存储池虽然也是静态分配的，但若同时存在若干个结点类型相同的链表，则它们可以共享空间，动态链表的存储空间是动态分配的，只要内存空间尚有空闲，就不会产生溢出。
因此，当线性表的长度变化较大，难以估计其存储规模时，采用动态链表作为存储结构较好。
**<u>存储密度(Storage Density)</u>**是指结点数据本身所占的存储量和整个结点结构所占的存储量之比。一般地，存储密度越大，存储空间的利用率就高。显然，顺序表的存储密度为1，而链表的存储密度小于1。

#### 基于时间的考虑

顺序表是由向量实现的，它是一种随机存取结构，对表中任一结点都可以在0(1)时间内直接地存取，而链表中的结点，需从头指针起顺着链找才能取得。因此，若线性表的操作主要是进行**<u>查找</u>**，很少做插入和删除时,**<u>宜采用顺序表做存储结构</u>**。
在链表中的任何位置上进行插入和删除，都只需要修改指针。而在顺序表中进行插入和删除，平均要移动表中近一半的结点，尤其是当每个结点的信息量较大时，移动结点的时间开销就相当可观。因此，对于**<u>频繁进行插入和删除的线性表，宜采用链表做存储结构</u>**。若表的插入和删除主要发生在表的首尾两端，则宜采用尾指针表示的单循环链表。

#### 基于语言的考虑

在没有提供指针类型的高级语言环镜中，若要采用链表结构，则可以使用光标实现的静态链表。虽然静态链表在存储分配上有不足之处，但它是和动态链表一样,具有插入和删除方便的特点。
值得指出的是，即使是对那些具有指针类型的语言，静态链表也有其用武之地。特别是当线性表的长度不变，仅需改变结点之间的相对关系时，静态链表比动态链表可能更方便。

### 线性表链式存储方式的比较

|                              | 找首元素节点             | 找尾节点                  | 找P节点前驱节点                                     |
| ---------------------------- | ------------------------ | ------------------------- | --------------------------------------------------- |
| 带头结点单链表L              | L->next<br/>时间耗费O(1) | 一重循环<br/>时间耗费O(n) | 顺P结点的next域无法找到P结点的前驱                  |
| 带头结点循环单链表（头指针） | L->next<br/>时间耗费O(1) | 一重循环<br/>时间耗费0(n) | 顺P结点的next域可以找到P结点的前驱<br/>时间耗费0(n) |
| L带尾指针的循环单链表R       | R->next<br/>O(1)         | R<br/>时间耗费0(1)        | 顺P结点的next域可以找到P结点的前驱<br/>时间耗费0(n) |
| 带头结点双向循环链表L        | L->next<br/>O(1)         | L->prior<br/>时间耗费0(1) | P->prior<br/>时间耗费0(1)                           |

## 总结与提高

### 主要知识点

#### 线性表的特征

线性表中每个数据元素有且仅有一个直接前驱和一个直接后继，第一个结点无前驱，最后一个结点无后继。

#### 线性表存储方式

实现线性表在计算机中的存放有**顺序存储**与**链式存储**两种方式。
线性表顺序存储（顺序表）:采用静态分配方式，借助于C语言的数组类型，申请一组连续的地址空间，依次存放表中元素，其逻辑次序隐含在存储顺序之中。
线性表链式存储（链表）:采用动态分配方式，借助于C语言的指针类型,动态申请与动态释放地址空间，故链表中的各结点的物理存储可以是不连续的。

#### 单链表的操作特点

- 顺链操作技术:从“头”开始，访问单链表L中结点i(p指向该结点）时，由于第i个结点的地址在第i-1个结点（pre指向该结点，为p的前驱）的指针域中存放，查找必须从单链表的“首结点”开始（p=L）;通过p=p->next并辅助计数器来实现;
- 指针保留技术:对第i个结点进行插入、删除等操作时，要对第i-1个结点的指针域进行链址操作（pre->next) ,因此在处理过程中始终需要维持当前指针p与其前驱指针pre的关系，将这种技术简称为“指针保留技术”。

#### 链表处理中的相关技术

- 单链表与多重链表的差别在于指针域的个数;
- 一般链表与循环链表的差别在于是否首尾相接,将非空表、空表等多种情况统一处理，以方便运算。
- 判断当前结点p是否为表尾:一般链表中,p结点是表尾的条件是:该结点的后继指针值为空指针即:p->next==NULL，循环链表中，p结点是表尾结点的条件是:该结点的后继指针值为头指针值即:p->next= = head 。
- 链表的表长度n值并未显式保存:由于链表是动态生成的结构，其长度要通过顺链查找到表尾得到。因此在处理链表时，往往以当前处理位置结点p是否为表尾作为控制条件。

### 典型题例

#### 例1分解顺序表为奇偶两部分

【例1】已知顺序表L中的数据元素类型为int。设计算法将其调整为左右两部分，左边的元素（即排在前面的）均为奇数，右边所有元素（即排在后面的）均为偶数，并要求算法的时间复杂度为0(n)，空间复杂度为0（1) 。

【问题分析】

- 题目要求空间复杂度为0(1)
- 将位于表左半部分的偶数与位于表右半部分的奇数通过—个辅助变量进行交换
- 设置两个位置指示器i和j,i初值为0，j初值为L->last.
- 当L->elem[i]为偶数，L->elem[j]为奇数时,则将L->elem[i]与L->elem[j]交换;
- 否则，L->elem[i]为奇数,i++，L->elem[j]为偶数，j--。
- 这样既可以保证算法的时间复杂度为0(n),亦可保证空间复杂度为0（1) 。

```c
AdjustSqlist(SeqList *L)
{
    int i=0，j=L->last;
    while(i<j)
    {
        while(L->elem[i]%2!=O)
            i++;
        while(L->elem[j]%2==O)
            j--;
        if(i<j)
            {
                t= L->elem[i];
                L一>elemLi一L->elem[j]=t;
            }
    }
}										/*end of AdjustSql ist*/
```

#### 例2单链表就地逆置问题

【例2】算法实现带头结点单链表的就地逆置问题。

【问题分析】
逆置就是使得表中内容由原来的
$$
( a_1,a_2,\cdots,a_{i-1},a_i,a_{i+1},\cdots,a_n）
$$
变为
$$
( a_n,a_{n-1},\cdots,a_{i+1},a_i,a_{i-1},\cdots,a_1)
$$
**就地逆置**就是不需要额外申请结点空间，只需要利用原有的表中的节点空间。

```c
void ReverseList(LinkList L)				/*逆置带头结点的单链表L*/
{
    p=L->next;								/*记录原表第一个元素结点的地址*/
    L->next=NULL;						/*将头结点的next域置空得新空链表*/
    while(p!=NULL)									/*从原表摘下结点，并头插到新表中*/
        {
            q=p->next;
            p->next=L->next; 
            L->next=p;
            p=q;
        }
}
```

【思考】

已知一个带头结点的单链表L，设计算法实现:以表中第一个元素作为标准,将单链表中所有值小于第一个元素的结点均放在第一个元素结点之前，所有值大于第一个元素的结点均放在第一个元素结点之后。

**<u>(提示:此题可以利用头插法)</u>**

#### 例3二进制数加1运算

【例3】建立一个带头结点的线性链表,用以存放输入的二进制数,链表中每个结点的data域存放一个二进制位。并在此链表上实现对二进制数加1的运算。

【问题分析】

①建链表:二进制数可用带头结点的单链表存储，第一个结点存储二进制数的最高位。
②二进制数加1运算规则:从低位往高位找到第一个值为0的位，把该位改为1，其后所有各位改为0。
③链表实现方法:从高位往低位，从第一个结点开始，找出最后一个值域为0的结点,把该结点值域赋为1，其后所有结点的值域赋为0。
④若在链表中未找到值域为0的结点，则表示该二进制数各位均为1，此时，申请一新结点，值域置为1,头插入到原链表,其后所有结点的值域置为0。

```c
void BinAdd (LinkList l)
{
    Node *q,*r，*temp, *s;
    q=l->next;
    r=l;
    while(q!=NULL)
    /*找最后一个值域为0的结点*/
    {
        if(q->data == 0)
            r = q;
        q = q->next;
     }

        if(r != l)
            r->data = 1;			/*把该结点值域赋为1*/
        else
            {
                temp = r->next;			/*申请新结点，值域置为1,头插入原表*/s=(Node*)malloc(sizeof (Node)) ;
                s->data=1;
                s->next=temp;
                r->next = s;
                r =s;
            }
        r = r->next;
        while(r !=NULL)				/*进位结点后所有结点的值域置为O*/
            {
                r->data = 0;
                r = r->next;
            }
}
```



_____

# 限定性线性表———栈与队列

限制线性表插入和删除等运算的位置（只允许在端点位置操作）

## 栈

### 栈的定义

栈的定义:把线性表的插入和删除运算限制在表的一端进行。通常将表中允许进行运算端称为**栈顶**(Top)，不允许运算的另一端被称为**栈底**(Bottom)。由于栈顶位置是动态变化的,需要设置栈顶指示器。
**空栈:**当栈中没有元素时称为。

栈的常见运算:

进栈或入栈(表尾插入)
出栈或退栈(表尾删除)

栈的特性:后进先出(LIFO)。

**<u>数据元素:</u>**可以是任意类型的数据，但必须属于同一个数据对象。

**<u>关系:</u>**栈中数据元素之间是线性关系。
**<u>基本操作:</u>**

(1) InitStack(S)
(2 ClearStack(S)
(3 lsEmpty(S)
(4) IsFull(S)
(5) Push(S,x)
(6) Pop(S,x)
(7) GetTop(S,x)

###  栈的表示和实现

栈在计算机中主要有两种基本的存储结构:顺序存储结构和链式存储结构。

#### 顺序栈

1.定义
用一组**连续**的存储单元依次存放**自栈底到栈顶**的数据元素。
设一个**位置指针top**(栈顶指针)动态指示栈顶元素在顺序栈中的位置。
top = -1表示空栈。

##### 用C语言定义栈的顺序存储结构

```c
#define TRUE 1
#define FALSE 0
#define Stack_Size 50
typedef struct
{
    StackElementType elem[Stack_Size];
    int top;
} SeqStack;
```

##### 顺序栈基本操作的实现

###### 1) 初始化

```c
void InitStack(SeqStack *S)
{
	S->top= -1;							/*构造一个空栈S*/
}
```

###### 2) 判栈空

```c
int IsEmpty(SeqStack *S)
{
	return(S->top==-1?TRUE:FALSE);				/*判栈S为空栈时返回值为真，反之为假*/
}
```

###### 3) 判栈满

```c
int IsFull(SeqStack *S)
{
	return(S->top== Stack_Size-1?TRUE:FALSE);			/*判栈S为满时返回真，否则返回假*/
}
```

###### 4) 进栈

```c
int Push(SeqStack *S,StackElementType x)
{
    if(S->top=-Stack_Size-1) return(FALSE);					/*栈已满*/
    S->top++;
    S->elem[s->top]=x;
    return(TURE);
}
```

###### 5) 出栈

```c
int Pop(SeqStack *S, StackElementType *x)
{												/*将栈S的栈顶元素弹出，放到x所指的存储空间中*/
    if(S->top= =-1)														/*栈为空*/
        return(FALSE);
    else
    {
        *x=S->elem[S->top];
        S->top--;												/*修改栈顶指针*/
        return (TRUE);
    }
}
```

###### 6) 读栈顶元素

```c
int GetTop ( SeqStack S, StackEl ementType *x )
{												/*将栈S的栈顶元素弹出,放到x所指的存储空间中,但栈顶指针保持不变*/
    if(S→>top==-1)												/*栈为空*/
        return(FALSE);
    else
    {
        *x = S ->elem [S->top];
        return(TRUE);
    }
}
```

###### 7) 两栈共享的数据结构

**两栈共享栈空间示意图**

主要利用了栈栈底位置不变,而栈顶位置动态变化的特性。首先为两个栈申请一个共享的一维数组空间S[M],将两个栈的栈底分别放在一维数组的两端,分别是0,M-1。
共享栈的空间示意为: top[0]和top[1]分别为两个栈顶指示器。

**两栈共享的数据结构定义**

```c
#define M 100
typedef struct
{
    StackElementType Stack[M;				/* Stack[M]为栈区*/
    int top[2];							/*top[0]和top[1]分别为两个栈顶指示器*/						
}DqStack;
```

**初始化操作算法**

```c
void InitStack (DqStack *S)
{
	S->top[0]=-1;
	S>top[1]=M;
}
```

**进栈操作算法**

```c
int Push( DqStack *S,StackEl ementTypex，int i)
{
    if (S->top[0]+1==S->top[1] )				/*栈已满*/
        return(FALSE);
    switch(i)
        {
            case 0:s>top[0]++; s>Stack[S->top[0]]=x; break;
            case 1 : s>top[1]--;s >Stack[S->top[1]]=x; break;
            default: return(FALSE)
        }
    return (TRUE);
}
```

**出栈操作算法**

```c
int Pop( DqStack *S,StackElementType *x, int i)
{
    switch(i)
        {
            case 0: if(S>top[0]==-1)
                return(FALSE);
                *x=S >Stack[S->top[0]];
                S->top[0]--; break;
            case 1 : if (S>top [1]==M)return(FALSE);
                *x=S>Stack[S ->top[1]];
                S >top[1]++;break;
            default: return(FALSE);
        }
    return(TRUE);
}
```

#### 链栈

##### 链栈的定义及示意图

采用带头结点的单链表实现链栈。
头指针就作为栈顶指针。

top为栈顶指针,始终指向当前栈顶元素前面的头结点。
若top->next==NULL则代表空栈。

注意:链栈在使用完毕时，应该释放其空间。

```
top--->▢▥--->▢▥--->▢▥--->▢▥
```

##### 用C语言定义的链栈结构

```c
typedef struct node
    StackElementType data;
    struct node *next;
}LinkStackNode;
typedef LinkStackNode * LinkStack ;
```

**链栈的进栈操作**

```c
int Push(LinkStacktop, StackElementType x)			/*将数据元素x压入栈top中*/
{
    LinkStackNode * temp;
    temp=(LinkStackNode * )malloc(sizeof(LinkStackNode));
    if(temp==NULL)
        return(FALSE);										/*申请空间失败*/
    temp->data=x;
    temp->next=top->next;
    top->next=temp;/*修改当前栈顶指针*/return(TRUE);
}
```

##### 链栈的出栈操作

```c
int Pop(LinkStacktop,StackElementType*x)
{											/*将栈top的栈顶元素弹出，放到x所指的存储空间中*/
    LinkStackNode * temp; 
    temp=top->next;
    if(temp==NULL)/*栈为空*
        return(FALSE);
    top->next=temp->next;
    *x=temp->data;free(temp);									/*释放存储空间*/
    return(TRUE);
}
```

##### 多栈运算

**算法思想**

```c
将多个链栈的栈顶指针放在一个一维指针数组中来统一管理,从而实现同时管理和使用多个栈。
#define M 10
							/*M个链栈*/
typedef struct node
{
	StackElementType data;
	struct node *next;
} LinkStackNode, LinkStack;
```

**示意图**

![](https://p.ananas.chaoxing.com/star3/1412_870Q50/4e63b95d4befad628de39d619948a153.png?rw=1412&rh=870&_fileSize=133567&_orientation=1)

**基本操作**

**第i号栈元素进栈操作**

```c
int pushi(LinkStack top[M],int i, StackElementType x)
{
    LinkStackNode *temp ;
    temp=(LinkStackNode *)malloc(sizeof(LinkStackNode));
    if(temp==NULL)
    	return(FALSE);
    temp->data=x ;
    temp->next=top[i]->next;
    top[i]->next=temp ;
    return (TRUE);
}
```

**第i号栈元素出栈操作**

```c
int Pop (LinkStack top[M],int i, StackElementType *x)
{
LinkStackNode *temp ;
temp=top[i]->next;
if(temp==NULL)
	return(FALSE);
top[i]->next=temp->next ;
*x=temp->data;
free(temp);
return (TRUE);
}
```

### 栈的应用举例

##### 括号匹配问题

算法思想:
在检验算法中设置一个栈,若读入的是左括号，则直接入栈,等待相匹配的同类右括号;若读入的是右括号,且与当前栈顶的左括号同类型，则二者匹配,将栈顶的左括号出栈,否则属于不合法的情况。

```c
voidBracketMatch(char *str)
{
    Stack S; int i; char ch;
    InitStack (&S);
        For(i=O;str[i]!='1O'; i++)
        {
            switch(str[i])
                {
                    case '(":
                    case '[':
                    case '{':
                        Push(&S,str[i]); break;
                    case ')":
                    case ']":
                    case '}':
                        if(IsEmpty(S))
                            {printf("In右括号多余!");return;}
                          else
                            {
                                GetTop(&s,&ch);
                                if(Match(ch,str [i]))
                                    Pop(&s,&ch);
                                else
                                    {
                                        printf("In对应的左右括号不同类!");
                                        return;
                                    }
                            }
                }/*switch*/
        }/*for*/
    if(IsEmpty(s))
        printf("In括号匹配!");
    else
        printf("In左括号多余!");
}
```

#### 表达式求值

**算术表达式处理规则**
一、规定运算符的优先级表
二、设置两个栈:0VS(运算数栈)、OPTR(运算符栈)

三、自左向右扫描，进行如下处理:
遇到运算数则进OVS栈;

遇到运算符则与OPTR栈的栈顶运算符进行优先级比较:

如果当前运算符>0PTR栈顶运算符,则当前运算符进OPTR栈

如果当前运算符≤0PTR栈顶运算符,则OPTR退栈一次,得到栈顶运算符@, 0VS连续退栈两次，得到运算数a、运算数b,对a、b执行@操作，得到结果T(i)，将T(i)进VOS栈。

### 栈与递归的实现

**递归**:在定义自身的同时又出现了对自身的调用。

**直接递归函数**:如果一个函数在其定义体内直接调用自己，则称直接递归函数。

**间接递归函数**:如果一个函数经过一系列的中间调用语句,通过其它函数间接调用自己则称间接递归函数。

#### 递归特性问题

##### 递归定义的数学函数

二阶Fibonacci数列：
$$
Fib(n)=\begin{cases}
0&n=0\\1&n=1\\Fib(n-1)+Fib(n-2)&n>1
\end{cases}
$$
阿克曼函数：
$$
Ack(m,n)=\begin{cases}
n+1&m=0\\Ack(m-1,1)&m\neq0,n=0\\Ack(m-1,Ack(m,n-1))&m\neq,n\neq0
\end{cases}
$$
**用C语言函数描述Ackerman函数**

```c
int ack(int m,int n)
{
    if(m==0) 
        return n+1;
    else if (n==O) 
        return ack(m-1,1);
    else return 
    	ack(m-1,ack(m,n-1));
}
```

##### 递归数据结构的处理

我们在后续章节将要学习的些数据结构,如**广义表、二叉树、树**等结构其本身均具有固有的递归特性,因此可以自然地采用**递归法**进行处理。

##### 递归求解方法

典型例子:汉诺塔(hanoi)问题的算法实现

伪代码：

```c
void hanoi(int n,char x,char y,char z)/*将塔座X上按直径由小到大且至上而下编号为1至n的n个圆盘按规则搬到塔座Z上，Y可用作辅助塔座*/
{ 
    if(n==1)
        move(x,1,z);产*将编号为1的圆盘从X移动Z*/
    else 
        {
            hano(n-1,x,z,y);产*将X上编号为1至n-1的圆盘移到Y,Z作辅助塔*/
            move(x,n,z);/*将编号为n的圆盘从X移到Z*/
            hano(n-1,y , x,z);*将y上编号为1至n-1的圆盘移动到zx作辅助塔*/
    }
}
```

==递归问题的优点:==

- 对递归问题描述简捷
- 结构清晰
- 程序的正确性容易证明



设计递归算法的方法

使用递归算法的前提有两个:
(1)原问题可以层层分解为类似的的子问题，且子问题比原问题的规模更小。
(⑵规模最小的子问题具有直接解。

设计递归算法的原则是用自身的简单情况来定义自身

设计递归算法的方法是:
(1)寻找分解方法

将原问题转化为子问题求解（例: n!=n*(n-1)! )

(2)设计递归出口

即根据规模最小的问题,确定递归终止条件。(例:求解n!时，当n=1时,n!=1）。

#### 递归过程的实现

递归进层(i→i +1层)系统需要做三件工作:

(1)保留本层参数与返回地址;
(2)给下层参数赋值;
(3)将程序转移到被调函数的人口。

递归退层(i—i+1层)系统也应完成三件工作:

(1)保存被调函数的计算结果;
(2)恢复上层参数（释放被调函数的数据区
(3)依照被调函数保存的返回地址，将控制转移回调用函数。



一个递归函数的运行过程调用函数和被调用函数是同一个函数,因此，与每次调用时相关的一个重要的概念是递归函数运行的“层次”。假设调用该递归函数的主函数为第0层,则从主函数调用递归函数为进入第1层;从第i层递归调用本函数为进入“下一层”，即第i+1层。反之，退出第i层递归应返回至“上一层”，即第i-1层。为了保证递归函数正确执行,系统需设立一个**递归工作栈**作为整个递归函数运行期间使用的数据存储区。每层递归所需信息构成一个**工作记录**，其中包括所有的实在参数、所有的局部变量以及上一层的返回地址。每进人一层递归，就产生一个新的工作记录压人栈顶。每退出一层递归，就从栈顶弹出一个工作记录。因此当前执行层的工作记录必为递归工作栈栈顶的工作记录，我们称这个记录为**活动记录**，并称指示活动记录的栈顶指针为**当前环境指针**。



例如：
$$
n!=\begin{cases}
1&n=0
\\n\times(n-1)!&n>0
\end{cases}
$$
**其递归算法如下:**

```c
int f(int n)/*设n>=0*/
{
    if (n==0) 
        return (1);
    else 
        return (n*f(n-1));
}
```

#### 递归算法到非递归算法转换

递归算法到非递归算法转换:
递归算法的**两个特性**:
(1)递归算法是一种分而治之、把复杂问题分解为简单问题的求解问题方法，对求解某些复杂问题,递归算法分析方法是有效的。
(2）递归算法的时间效率差，其时间效率低。



##### 消除递归的原因

一、有利于提高算法时空性能,因为递归执行时需要系统提供隐式栈实现递归，效率低且费时。
二、无应用递归语句的语言设施环境条件有些计算机语言不支持递归功能,FORTRANBASIC语言。
三、递归算法是一次执行完,这在处理有些问题时不合适,也存在把递归算法转化为非递归算法的需求。



消除递归的两类方法:

一类是简单递归问题的转换,对于尾递归和单向递归的算法，可用循环结构的算法替代。
另一类是基于栈的方式，即将递归中隐含的栈机制转化为由用户直接控制的明显的栈，利用栈保存参数。



##### 简单递归的消除

==单向递归:==单向递归是指递归函数中虽然有一处以上的递归调用语句,但各次递归调用语句的参数只和主调用函数有关，相互之间参数无关,并且这些递归调用语句处于算法去的最后。

```c
/*非递归算法实现斐波那契数列*/

int fib(int n):
{
    int x,y,Z;
    if (n= =O||n= =1 
        return n;			/*计算b(O)b(1)*/
    else 
        {
            int x=O, y=1,z;			/* x=b(0) y=b(1)*/
            for ( i=2;i<= n; i ++)
                {
                    z:=y;						/*z=b(i-1)*/
                    y:=x+y;/*y=b(i-1)+b(i-2)求b(I)形成第i项*/
                    x=z;			 /*x=b(i-1)*/
                };                  
        }return y ;
}

```



==尾递归:==尾递归是指递归调用语句只有一个,而且是处于算法的最后,尾递归是单向递归的特例。

```c
用循环结构表示阶乘问题的算法如下:
long fact ( int n)
{
    int fac =1;
    for( int i=1;i<=n;i++)/*依次计算f(1) ... f(n)*/
    fac = fac * i; /*f(i)= f(i)* i*/
    return fac ;
}
```

## 队列

### 队列的定义

队列(Queue)是只允许在表的一端插入元素,而在另一端删除元素另一种限定性的线性表。允许册除的一端称**队头**,称为**队尾**。

特性:
先进先出(Fist In Fist Out, FIFO)



队列的抽象数据类型定义(ADT Queue)
**数据元素:**属于同一个数据对象的任意类型数据。

**关系:**队列中的数据元素之间是线性关系。

**基本操作:**

- (1)lnitQueue (&Q)
- (2) lsEmpty (Q)
- (3)lsFul l (Q)
- (4)EnterQueue (&Q ,x)
- (5) DeleteQueue (&Q,&x)
- (6)GetHead (Q,&x)
- (7)ClearQureue (&Q)
- (8)DestroyQueue (&Q)

### 队列的表示和实现

#### 链队列

队列有顺序表示和链式表示两种表示方法。

1.链队列:用链表表示的队列称为链队列

```c
#define TRUE 1
#define FALSE 0
typedef struct Node
{
    QueueElementType data;	/*数据域*/
    structNode next;		/*指针域*/
}LinkQueueNode;
typedef struct
{
    LinkQueueNode *front;
    LinkQueueNode *rear;
} LinkQueue ;
```

##### 初始化操作

```c
int InitQueue( LinkQueue*Q)
{				/*将Q初始化为一个空的链队列*/
    Q->front=(LinkQueueNode*)malloc(sizeof(LinkQueueNode));
    if(Q->front!=NULL)
    {
        Q->rear=Q->front;
        Q>front>next=NULL;
        return(TRUE);
    }
    else
        return(FALSE);/*溢出!*/
}
```

##### 入队操作

```c
int EnterQueue ( LinkQueue*Q, QueueElementType x)
{		/*将数据元素x插人到队列Q中*/
    LinkQueueNode * NewNode ;
    NewNode=(LinkQueueNodt ) malloc(sizeof(LinkQueueNode ));
    if(NewNode!=NULL)
        {
            NewNode >data=x;
            NewNode >next=NULL;
            Q->rear->next= NewNode;
            Q->rear=NewNode ;
            return(TRUE);
        }
    else
        return(FALSE);						/*溢出!*/
}

```

##### 出队操作

```c
int DeleteQueue(LinkQueue* Q, QueueElementType *x)
{					/Р*将队列Q的队头元素出队，并存放到x所指的存储空间中*/
    LinkQueueNode * p;
    if(Q->front==Q>rear)
        return(FALSE);
    p=Q->front->next;
    Q->front->next=p->next;/*队头元素*/

    if(Q->rear==p)/*如果队中只有一个元素p,则p出队后为空队*/
        Q->rear=Q->front;
    *x=p->data;
    free(p);/*释放存储空间*return(TRUE);
}
```

#### 循环队列

##### 循环队列的定义

- 用一维数组Queue [MAXSIZE]存放从队头到队尾的元素。
- 附设两个指针front和rear,分别指示队头元素和队尾元素在数组中的位置。
- 由于只能在队头出队,在队尾入队,所以会产生假溢出的现象

为了解决假溢出现象，可将顺序队列的数组看成一个环状的空间，即规定最后一个单元的后继为第一个单元，我们形象地称之为循环队列假设队列数组为Queue[MAXSIZE]，当rear+1=MAXSIZE时，令rear=0，即可求得最后一个单元Queue[MAXSIZE-1]的后继:Queue[0]。



还可通过数学中的取模〈求余）运算来实现:rear= (rear+1) mod MAXSIZE,
显然，当rear+1=MAXSIZE时,rear=0，同样可求得最后一个单元Queue[MAXSIZE-1]的后继:Queue[0]。
进队操作时，队尾指针的变化是:reara (rear+1 ) mod MAXSIZE
出队操作时，队头指针的变化是:front= (front+1) mod MAXSIZE





从上面给出的几种情况来看,只凭front=rear无法判别队列的状态是空还是满



==解决这个问题:==

方法一:少用一个元素空间,当队尾指针所指向的空单元的后继单元是队头元素所在的单元时,则停止入队。

队列满的条件为:(rear+1) mod MAXSIZE=front;

队列空的条件为:rear= front

方法二:增设一个标志量，以区别队列是空,还是满。



##### 循环队列的类型定义

```c
# define MAXSIZE 50
typedef struct
{
    QueueElementType element[MAXSIZE];
    int front;
    int rear ;
} SeqQueue ;
```

##### 循环队列的基本操作

###### 初始化操作

```c
void InitQueue(SeqQueue* Q)
{					/*将*Q初始化为一个的泪个队列'
	Q->front=Q>rear=O;
}
```



###### 入队操作

```c
int EnterQueue(SeqQueue*Q,QueueElementType x)
{											/*将元素x入队*/
    if((Q->rear+1)%MAXSIZE==Q->front)		/*队列已经满了/
        return(FALSE);
    Q->element[Q->rear]=x;
    Q->rear=(Q->rear+1)%MAXSIZE;		/*重新设置队尾指针/
    return(TRUE);						/*操作成功*/
}
```



###### 出队操作

```c
int DeleteQueue ( SeqQueue*Q,QueueElementType* x)
{										/*删除队列的队头元素，用x返回其值*/
    if (Q->front==Q->rear)				/*队列为空*/
    	return(FALSE);
    *x=Q->element[Q-→>front];
    Q->front=(Q- >front+1)%MAXSIZE;			/*重新设置队头指针
    *return(TRUE);							/*操作成功*/
}
```

### 队列的应用举例

#### 1.打印扬辉三角形

```c
voidYangHuiTriangle()
{
    SeqQueue Q;
    InitQueue (&Q);
    EnterQueue(&Q,1);/*第一行元素人队*/
    for(n=2;n<=N;n++)*产生第n行元素并人队，同时打印第n-1行的元素
        {
            EnterQueue (&Q,1);/*第n行的第一个元素入队*/
            for(i=1;i<=n -2;i++)*利用队中第n-1行元素产生第n行的中间n-2个元素并入队*/
            {
                DeleteQueue(&Q,&temp);
                Printf ( %d ,temp);l*打印第n-1行的元素*I
                GetHead(Q,&x); 
                temp=temp+x;/*利用队中第n 1行元素产生第n行元素*/
                EnterQueue (&Q,temp);
            }
            DeleteQueue (&Q,&x);
            printf (%d,x); printf("\n");*打印第n-1行的最后一个元素*/
            EnterQueue (&Q,1)/*第n行的最后一个元素人队*/
        }
    while ( !IsEmpty ( Q ) )/*打印最后一行元素*/
        {
            DeleteQueue ( &Q,&x);
            printf ( " %d " , x );
        }
}
```



#### 2键盘输入循环缓冲区问题

==问题描述:==有**两个进程**同时存在于一个程序中。其中**第一个进程**在屏幕上连续显示字符“A”，与此同时，程序不断检测键盘是否有输人，如果有的话，就读人用户输入的字符，并保存到输人**缓冲区**中。在用户输人时，输人的字符并不立即回显在屏幕上。当用户输人一个逗号(,)时，表示第一个进程结束。第二个进程从缓冲区中读取那些已输人的字符并显示在屏幕上。**第二个进程结束后**，程序又进人**第一个进程**,重新显示字符“A”，同时用户又可以继续输人字符，直到用户输人一个分号(;)键、才结束第一个进程。同时也结束整个程序。

```C
#define MAXSIZE 16
#define QueueElementType char
#define TRUE 1
#define FALSE 0
#include"stdio.h”
#include"conio.h”
#include"dos.h”
main()
{				/*模拟键盘输人循环缓冲区*/
    char ch1,ch2;
        SeqQueue Q;
        Int f;
        InitQueue (&Q);/*队列初始化*/
        For(;;)
            {
                for(;;)			/*第一个进程*
                {
                	printf("A");
                	if(kbhit())
            			{
                            ch1=bdos(7,0,0);/*通过dos命令读人一个字符。*/
                            f= EnterQueue (&Q,ch1);
                            if(==FALSE)
        						{
                                    printf(“循环队列已满\n");
                                    break;/*循环队列满时，强制中断第一个进程。*/
        						}
                                           
                                           
                         }       
                            	if(ch1==';'||ch1==',')
                                	break;/*第一个进程正常结束*
                    }
                         while (lsEmpty(Q)			/*第二个进程*/
                         {
                             DeleteQueue (&Q,&ch2);
                             putchar(ch2);			/*显示输人缓冲区的内容*/
                         }
            if(ch1== ';')
                break;/*整个程序结束*/
            else
                ch1= ’’;/*置空ch1，程序继续。*/
        }
}

```

## 总结与提高

### 3.3.1主要知识点

#### 基本概念

- 堆栈和队列，都是操作受限制的线性表，它们的共同点是操作的位置限制在表的端点。
- 维栈具有LlFO的特性,I限定兀系的运异1M置只在表尾（栈顶）端进行。
- 队列具有FlFO的特性。限定兀素的运异1M置分别在表的两端进行。

#### 顺序和链式两种存储方式

- 对进栈操作来说，顺序栈受到事先开辟的栈区容量限制，以避免上溢。链栈方式下，只有当整个系统无法申请到可用空间时,才无法进栈。队列操作亦同。
- 循环队列是一种顺序队列。通过模运算将其看成一个首尾相接的环。求队列的长度是模运算,为区分队列的空满，有两种典型的解决方法:一种是损失一个空间的方法;另一种是设置标志位的方法。
- 链队列的操作实现与单链表的操作实现类似，而链队列除了头指针,还设一个尾指针并且通常封装在一个结构体里。

#### 栈和队列的应用

(1）利用栈和队列都可以控制解决问题的顺序。
(2）凡是对元素的保存次序与使用顺序相反的,都可以使用栈;凡是对元素的保存次序与使用顺序相同的,可以使用队列。

#### 递归实现机制

- 递归工作栈是实现递归的核心技术。需明确递归进层与递归退层的相关工作。
- 递归的消除
  (1）在简单情况下，可以将递归算法转化为线性操作序列，直接用循环实现。
  (2 )一般情况下,可以利用自定义栈模拟系统栈,将递归算法转换为非递归算法。

### 3.3.2典型题例

#### 例1最大公约数问题

例1．设m、n均为正整数,指出如下递归函数的功能,并将其改写，要求执行时间尽可能短。

```c
int fun (int m,int n)
{int r ;
if (n>m)return (fun (n,m)else if(n==0)return (m) ;else {r=m%n ; return (fun(n,r)); }}
```

**程序功能分析**

该算法要求第一个参数大于第二个参数,否则将换位。当m大于n时，首先求出m除以n的余数r，然后让n做第一个参数,让r做第二个参数，重复上述过程。这是辗转相除法的过程。
该函数的功能是求m和n的最大公约数。

**改写思路**

要将上述最大公约数的递归函数改写,由于递归执行时间长，要使执行时间尽可能短,关键要将递归变为非递归，对求最大公约数的辗转相除法可以化成迭代的直线型循环实现。

**算法描述**

```c
int fun ( int m,int n)
{
    int r ;
    do
    {
        r=m%n ;
        m=n ;n=r ;
    } while (r!=0) ;
    return (m) ;
}
```

#### 例2排队就诊问题

例2．队列应用一模拟患者医院看病过程患者医院看病过程:先排队等候,再看病治疗。在排队的过程中主要重复做两件事情，一是患者到达诊室时,将病历交给护士，排到等候队列中候诊（进队操作）;二是护士从等候队列中取出下一个患者的病历，该患者进入诊室看病（出队操作）。

**算法思想**

在排队时按照“先到先服务”的原则，设计一个算法模拟病人等候就诊的过程。其中“病人到达”
用命令a表示，“护士让下一位患者就诊”用命令n表示，“不再接受病人排队”用q表示。

1. 本算法采用链队存放患者的病历号。
2. 当有“病人到达”命令时，则入队;当有“护士让下一位患者就诊”命令时，则出队﹔
3. 当有“不再接收病人排队”命令时,则队列中所有元素出队,程序终止。

**算法描述**

```c
void SeeDoctor ()
{ 
InitQueue (Q) ;
flag=1;
while(flag)
{
    printf ( “\n请输入命令:”) ;
    ch=getch
    switch (ch){
    case 'a’:
        printf ("\n病历号:”) ;
        scanf (“%d” , &n) ;
        EnterQueue (&Q， n) ; break
    case'n': 
        if (!IsEmpty(Q))
        {
            DeleteQueue (&Q,&n) ;
            printf ( “\n病历号为%d的病人就诊”,n) ; 
        }
        else
            printf( "\n无病人等候就诊”) ;break ;

    case'q':: printf (“\n今天停止挂号，下列病人依次就诊”) ;
        while (!IsEmpty (Q))
        {
            DeleteQueue (&0,&n) ;
            printf (“%d”，n) ; 
        }
        flag=0 ; break ;
    default : printf ( “\n非法命令!”);}
}
```

___

# 第4章 串

## 4.1串的基本概念

串(String)的定义
**字符串:**零个或多个字符组成的有限序列。
记为:```S='a1a1...an'```
串的名字:S;
串的值:单引号括起来的字符序列,每个ai(1≤i≤n)可以是字母,数字或其他字符;串的长度:n是串中字符的个数;
空串(Null String) :n=O时的串。
注:串值必须用一对单引号括起来(C语言中是双引号),但单引号是界限符,它不属于串,其作用是避免串值与变量名或常量混淆。



子串:串中任意个连续的字符组成的子序列称为该串的子串。
主串:包含子串的串称为主串。
子串在主串中的位置:通常将字符在串中的序号称为该字符在串中的位置。子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。



串相等:当且仅当两个串长度相等,并且每个对应位置的字符都相等时才相等。
空串与空格串的区别:由一个或多个称为空格的特殊字符组成的串,称为空格串(Blank Strin
ring)，其长度为串中空格字符的个数,而空串是无任何字符组成的串,其串长度为零。



### 基本操作

(1)StrAsign (S, chars)

初始条件:chars是字符串常量
操作结果:生成一个值等于chars的串S

(2)StrInsert(S, pos,T)

初始条件:串S和T存在,1 ≤pos ≤StrLength (S)+1
操作结果:在串S的第pos个字符之前插入串T

(3)StrDelete(S, pos,len)

初始条件:串S存在,1 ≤pos ≤StrLength (S)-len+1
操作结果:从串S中删除第pos个字符起长度为len的子串

(4)StrCopy (S,T)

初始条件:串S存在
操作结果:由串T复制得串S

(5)StrEmpty (s)

初始条件:串S存在
操作结果:若串S为空串，则返回TRUE,否则返回FALSE

(6)StrCompare(s,T)

初始条件:串S和T存在
操作结果:若S>T，则返回值>0;若S=T，则返回值=0;若S<T，则返回值<0

(7)StrLength(S)

初始条件:串S存在
操作结果:返回串S的长度,即串S中的元素个数



(8)StrClear(S)

初始条件:串S存在

操作结果:将S清为空串

(9)StrCat (S,T)

初始条件:串S和T存在
操作结果:将串T的值连接在串S的后面

(10)SubString (Sub, S, pos,len)

初始条件:串S存在，1≤pos ≤StrLength (S)1≤len≤ StrLength (S)-pos+1
操作结果:用Sub返回串S的第pos个字符起长度为len的子串



( 11)Strlndex (S, T, pos)
初始条件:串S和T存在，T是非空串,1pos ≤StrLength (S)
操作结果:若串S中存在与串T相同的子串，则返回它在串S中的第pos个字符之后第—次出现的位直,否则仅回0

(12 )StrReplace (S, T, V)
初始条件:串S,T和V存在,且T是非空串

操作结果:用V替换串S中出现的所有与T相等的不重叠子串

(13 )StrDestroy (S)

初始条件:串S存在

操作结果:销毁串S

## 4.2串的存储实现

### 4.2.1定长顺序串

串的定长顺序存储定义:

```c
define MAXLEN 20
typedef struct {
    char ch[MAXLEN];
    int len;
} SString;
```

1、串插入函数

在进行串的插人时，插人位置pos 将串分为两部分（假设为A、B,长度为LA、LB),及待插人部分（假设为C,长度为LC,则串由插人前的AB变为ACB，可能有三种情况:
1.插入后串长(LA+LC+LB)<MAXLEN 

则将B后移LC个元素位置，再将插入。

2.插入后串长>MAXLEN 且pos+LC<MAXLEN

则B后移时会有部分字符被舍弃。

3插入后串长>MAXLEN且pos+LC>MAXLEN:

则B的全部字符被舍弃〈不需后移)﹐并且在插人时也有部分字符被舍弃。

```c
Strlnsert(s,pos,t)/*在串s中序号为pOs的字符之前插入串t*/
SString *s,t;
int pos;
{
	int i;
	if (pos<0 ll pos>s>len) 
		return(O);			/*插入位置不合法*/
if (s>len + t.len<=MAXLEN)
	{			//插人后串长≤MAXLEN
        for (i=s->len + t.len-1;i>=t.len + pos;i--)
        s>ch[li]=s->ch[i-t.len];
        for (i=O;i<t.len;i++) s->ch[i+pos]=t.ch[t];
        s->len=s->len+t.len;
	}
else if (pos+t.len<=MAXLEN)
    {
        back
        //插人后串长>MAXLEN ,但串t的字符序列可以全部插人
        for (i=MAXLEN -1 ;i>t.len+pos-1;i--)
            s ->ch[i]=s->ch[i-t.len];
        for (i=0;i<t.len;i++)
        s->ch[i+pos]=t.ch[i];
        s->len=MAXLEN;
    }
else 
	{ //串t的部分字符序列要舍弃
        for (i=0;i<MAXLEN-pos;i++)
            s->ch[i+pos]=t.ch[ti];
        s->len=MAXLEN;
	}
return(1);
}
```



2、串删除函数

```c
StrDelete(s,pos,len)				/*在串s中删除从序号pos起len个字符*/
SString*s;int pos,len;
{
int i;
if (pos<0 ll pos>(s->len-len))
	return(O);
for (i=pos+len;i<s->len;i++)
	s>ch[i-len]=s->ch[i];
s->len=s->len- len;
return(1);
}
```

3、串复制函数

```c
StrCopy(s,t)		/*将串t的值复制到串s中
SString*s,t;
{
    int i;
    for (i=0;i<t.len;i++)
        s->ch[i]=t.ch[i];
    s->len=t.len;
}
```

4、判空函数

```c
StrEmpty(s)		/*若串s为空(即串长为0),则返回1,否则返回0*/
sString s;
{
    if (s.len==O) 
        return(1);
    else return(O);
}
```

5、串比较函数

```c
StrCompare(s，t)
/*若串s和t相等，则返回0，若s>t返回1，若s<t返回-1*/
SString s，t;
{
    int i;
    for (i=0;i<s.len&&i<t.len;i++)
        if (s.ch[i]!=t.ch[i])
            return(s.ch[i] - t.ch[i]);
    return(s.len - t.len);
}
```

6、求串长函数

```c
StrLength(s)			/*返回串s的长度*/
SString s;
{
	return(s.len);
}
```

7、清空函数

```c
StrClear(s)/将串s置为空串*/
SString *s;
{
	S>len=0;return(1);
}
```

8、连接函数

```c
StrCat(s,t)		/*将串t联接在串s的后面*/
SString*s,t;
{
int i,flag;
	if (s->len+ t.len<=MAXLEN)*联接后串长小于MAXLEN*/
	{
		for (i=s->len; i<s->len+ t.len; i++)
			s>ch[i]=t.ch[i-s->len;
		s->lenr=t.len;flag=1;
	}
    else if (s->len<MAXLEN)
        {								/*联接后串长大于MAXLEN ,但串s的长度小于MAXLEN即联接后串t的部分字符序列被舍弃*/
            for (i=s->len;i<MAXLEN;i++)
                s->ch[i]=t.ch[i-s->len];
            s>len=MAXLEN;
            flag=O;
        }
    else 
        flag=O;
        /*串s的长度等于MAXLEN,串t不被连接*/
return(flag);
}

```

9、求子串函数

```c
SubString(sub,s,pos,len)
/*将串s中序号pos起len个字符复制到sub中*/
SString *sub,s;
int pos,len;
{
    int i;
    if (pos<0 ll pos>s.len ll len<1 ll len>s.len-pos)
        {
            sub->len=0;
            return(0);
        }
    else
        {
            for (i=0;i< len;i++) sub->ch[i]=s.ch[i+pos];
                sub->len=len;
            return(1);
        }
}

```

10、简单模式匹配函数

```c
Strlndex(s,pos,t)
/*求串t在串s中的位置*/
SString s,t;
int pos;
{
    int i,j;
    if (t.len==O) 
        return(0);
    i=pos;
    j=0;
    while (i<s.len & & j<t.len)
        if (s.ch[i]==t.ch[i])
        {
            i++;
            j++;
        }
        else 
        {
            i=i-j+1;j=0;
        }
        if (j>=t.len) 
            return(i-j);
        else 
            return(O);
}
```



### 4.2.2堆串

堆:系统将一个地址连续、容量很大的存储空间作为字符串的可用空间。
每当建立一个新串时,系统就从这个空间中分配一个大小和字符串长度相同的空间存储新串的串值。

### 4.2.3块链串

#### 堆串的存储表示

```c
typedef struct
{
    char *ch ;
    int len ;
}HString ;
```



#### 堆串的基本操作

##### 串赋值函数

```c
StrAsign (s , tval)			/*将字符常量tval的值赋给串s */
HString*s; char *tval ;
{
int len i=O;
	if (s->ch!=NULL) free(s->ch );
	while (tval [i]!='\O') 
		i++;
	len=i;
    if (len) 
        {
            s>ch=(char *)malloc(len);
            if (s->ch==NULL)
                return(O);
            for (i=O;i<len;i++) s->ch[i]=tval[i];
        }
	else 
		s->ch=NULL; 
    s>len=len;
    return(1);
}
```

##### 求串长函数

```c
StrLength(s)/*返回串s的长度*/
HString s;
{
	return(s.len);
}
```



##### 串插入函数

````c
StrInsert(s, pos,t)			/*在串s中序号为pos的字符之前插入串t */
HString*s, t; 
int pos;
{
	int i;char *temp;
    if (pos<0 ll pos>s->len ll s->len ==O) 
    	return(0);
    temp=(char *)malloc(s->len + t. len);
	if (temp==NULL) 
		return(O);
	for (i=0;i<pos;i++)
		temp[i]=s->ch[i];
	for (i=0;i<t.len;i++)
		temp[i+pos]=t. ch[i];
	for (i=pos;i<s->len;i++)
		temp[i + t.len]=s->ch[i];
	s>len+=t.len;
	free(s->ch);
	s->ch=temp;
	return(1);
}
````



##### 清空函数

```c
StrClear(s)	/*将串s置为空串*/
HString *s;
{
	if (s->ch!=NULL) 
		free(s->ch);
	s->ch=NULL;
	s->len=0;
	return(1);
}
```



##### 串删除函数

```c
StrDelete(s，pos , len)		/*在串s中删除从序号pos 起len个字符*/
HString*s;
int pos len;
{
	int i; char *temp;
	if (pos<0 ll pos>(s->len- len )) 
		return(O);temp=(char *) 
	malloc (s->len- len);
	if (temp==NULL) 
		return(O);
	for (i=O;i<pos;i++) 
		temp[i]=s->ch[i];
	for (i=pos;i<s->len-len;i++)
		temp[i]=s->ch[i+ len];
	s>len=s->len-len ; 
	free(s->ch );
	s->ch =temp;
	return(1);
}
```



##### 连接函数

```c
StrCat(s,t)/*将串t联接在串s的后面*!HString *s，t;
{
    int i;
    char *temp;
    temp=(char *)malloc(s->len + t.len);
    if (temp==NULL) 
    	return(O);
    for (i=0;i<s->len;i++)
    	temp[i]=s->ch[i];
    for (i=s->len;i<s->len + t.len;i++)
    	temp[i]=t.ch[i-s->len];
    s->len+=t.len;
    free(s->ch);
    s->ch=temp;
    return(1);
}
```



##### 串复制函数

```c
StrCopy(s,t)		/*将串t的值复制到串s中*/
HString *s,t;
{
int i;
S->ch=(char *)malloc(t.len);
if (s->ch==NULL)
	return(O);
for (i=O;i<t.len;i++)
	s->ch[i]=t.ch[i];
s->len=t.len;
return(1);}
```



##### 求子串函数

```c
SubString(sub,s,pos，len)
/*将串s中序号pos起len个字符复制到sub中*/
HString *sub，s;
int pos，len;
{
    int i;
    if (sub->ch!=NULL)
        free(sub->ch);
    if (pos<0 ll pos>s.len ll len<1 ll len>s.len-pos)
        {
            sub->ch=NULL;
            sub->len=O;
            return(0);
        }
    else
        {
            sub->ch=(char *)malloc(len);
            if (sub->ch==NULL)
                return(O);
            for (i=o;i<len;i++)
                sub->ch[i]=s.ch[i+pos];
            sub->len=len;
            return(1);
        }
}
```



##### 判空函数

```c
StrEmpty(s)		/*若串s为空(即串长为0)，则返回1，否则返回0*/
HString s;
{
	if (s.len==0) 
		return(1);
	else
		return(O);
}
```



##### 定位函数

```c
Strlndex(s,pos，t)*求串t在串s中的位置*/
HString s，t;
int pos;
{
    int i，j;
    if (s.len==O ll t.len==O) 
    	return(O);
    i=pos;
    j=0;
    while (i<s.len && j<t.len)
    	if (s.ch[i]==t.ch[]) 
            {
                i++;
                j++;
            }
    	else 
            {
                i=i-j+1;
                j=0;
            }
    if (j>=t.len) 
    	return(i-j);
    else
    	return(O);
}
```



##### 串比较函数

```c
StrCompare(s，t)
/*若串s和t相等，则返回0，若s>t返回正数，若s<t返回负数*/
HString s,t;
{
    int i;
    for (i=o;i<s.len&&i<t.len;i++)
    	if (s.ch[i]!=t.ch[i])
    		return(s.ch[i]- t.ch[i]);
    	return(s.len - t.len);
}
```



## 4.3串的应用举例:简单的行编辑器

可将文本看成一个大的字符串，文本编辑就相当对字符串的处理.文本编辑程序用于原程序的输入和修改,公文书信,报刊和书籍的编辑排版等。常用的文本编辑程序有Edit,Wps, Word等。文本编辑的实质是修改字符数据的形式和格式,虽然各个文本编辑程序的功能不同,但基本操作是一样的,都包括串的查找,插入和删除等。

为了编辑方便，可以用分页符和换行符将文本分为若干页，每页有若干行。我们把文本当作一个字符串,称为文本串,页是文本串的子串,行是页的子串。

我们采用堆存储结构来存储文本，同时设立页指针,行指针和字指针分列指乔怎谷的起字符，同时建立页表和行表存储每一页，每一行的起
始位置和长度。

## 4.4总结与提高

### 4.4.1主要知识点

- 字符串是一种特定的线性表,其特殊性就在于组成线性表的每个元素就是一个单字符。
- 字符串常用的存储方式有三种:顺序串、堆串和块链串。
- 顺序串以一维数组存储,运算实现类同顺序表。块链串以链表作为存储结构,运算实现类同链表。
- 串的模式匹配算法是本章的重点。简单的模式匹配算法,处理思路简单,由于是带回
  溯的处理,时间复杂度较高。
- 改进的模式匹配算法(KMP)，是无回溯的处理，提高了处理速度。

### 4.4.2典型题例

要求编写一个用带头结点的单链表实现串的模式匹配算法。
每个结点存放1个字符（结点大小为1）。借助于结点大小为1定义链串类型LKString。

【问题分析】

该算法类同顺序串的简单模式匹配，实现匹配过程序需考虑链表的特征（从头比较的技术，指针保留的技术)）。

【算法思想】

从主串s的第1个字符和模式串t的第1个字符开始比较，如果相等，就继续比较;如果不等，则从主串s的下一个字符开始重新和模式串t比较。直到模式串t中的每一个字符依次和主串s中的对应字符相等，则匹配成功，返回主串的当前起始位置指针。如果主串处理完还没有找到和模式串相同的子串，则称匹配不成功，返回空指针NULL。

【算法描述】

```c
Link *StrIndex (LKString *s,LKString *t)
{
	Link *sp，*tp，*start;
	if (t->len == 0) return s->head->next;/*空串是任意串的子串*/
		start = s->head->next;
						/*记录主串的起始比较位置*/
	sp = start;
							/*主串从start开始*/
	tp = t->head->next;
					/*模式串从第一个结点开始*/
	while(sp != NULL && tp != NULL)
		{
			if (sp->ch == tp->ch)		/*若当前对应字符相同，则继续比较*/
                {
                    sp = sp->next;
                    tp = tp->next;
                }
    		else			/*发现失配字符，返回到主串当前起始位置的下一个结点继续比较*/
                {	
                    start = start->next;
                    /*更新主串的起始位置*/
                    sp = start;
                    tp = t->head->next; 
                }
			/*模式串从第一个结点重新开始*/
		}
    if ( tp ==NULL)
        return start;/*匹配成功，返回主串当前起始位置指针*/
    else 
        return NULL;
}
/*匹配不成功，返回空指针*/
```



## 附录模式匹配的一种改进算法

模式匹配的一种改进算法——KMP算法
这种改进算法是D.E.Knuth与V.R.Pratt和J.H.Morris同时发现的，因此人们称它为克努特-莫里斯-普拉特算法(简称为KMP算法）。该算法可以在0(n+m)的时间数量级上完成串的模式匹配操作。其改进在于:每当一趟匹配过程中出现字符比较不等时,不需回溯i指针,而是利用已经得到的“部分匹配”的结果将模式向右“滑动”尽可能远的一段距离后,继续进行比较。



___

# 第5章数组与广义表

## 5.1数组的定义与运算

从逻辑结构上，数组可以看作是一般线性表的扩充。一维数组即为线性表，而二维数组可以定义为“其数据元素为一维数组（线性表)”的线性表。以此类推,即可得到多维数组的定义。

2.数组的运算
实际上数组是一组有固定个数的元素的集合。由于这个性质，使得对数组的操作不象对线性表的操作那样,可以在表中任意一个合法的位置插入或删除一个元素。
对于数组的操作一般只有两类:

(1）获得特定位置的元素值;

(2）修改特定位置的元素值。



基本操作:
(1) InitArray (A,n,bound, ...,bound,):

若维数n和各维的长度合法，则构造相应的数组A，并返回TRUE ;

(2) DestroyArray (A) :

销毁数组A;

(3) GetValue ( A,e, index, ... ,index:

若下标合法,用e返回数组A中由index,, ... ,index,所指定的元素的值。



(4)SetValue(A , e, index1) :

若下标合法,则将数组A中由index1所指定的元素的值置为e
==注意:==这里定义的数组下标是从1开始，与C语言的数组略有不同。

## 5.2数组的顺序存储与实现

数组是一种特殊的数据结构,给定数组的维数及各维长度,则数组中元素的个数是固定的,数组的基本操作中不涉及结构的变化,因此采用顺序存储表示比较适合。
在计算机中,内存储器的结构是一维的。对于一维数组可直接采用顺序存储,用一维的内存存储表示多维数组,就必须按某种次序将数组中元素排成一个线性序列,然后将这个线性序列存放在一维的内存储器中。



**数组的顺序存储结构有两种:**
一种是按行序存储,如高级语言BASICCOBOL和Pascal语言都是以行序为主。
另一种是按列序存储,如高级语言中的FORTRAN语言就是以列序为主。



**—维数组的地址计算**

一维数组中的元素只需要一个下标其实质是线性表,存储方法与晋通线性衣仔怕门70北相同,即将数组元素按它们的逻辑次序存储在一片连续的存储区域内。设一维数组为:
$$
A=(a_1,a_2,\cdots,a_i,\cdots,a_n) 
$$
数组中每个元素占size个存储单元则元素a1储存地址为: ```Loc ( a[i]] ) = Loc(a[1]) + (i-1) * size```

以二维数组Amn为例，假设每个元素只占一个存储单元，“以行为主”存放数组，下标从1开始,首元素a11的地址为Loc[1,1]求任意元素aj的地址,可由如下计算公式得到:

```c
Loc(a[0]0]) = Loc(a[1][1]) + n*(i-1) + (j-1)
```

如果每个元素占size个存储单元
则任意元素aij的地址计算公式为:

```c
Loc(a[i][j]) = Loc(a[1][1]) + (n * (i - 1) + j - 1) * size
```



假定每个元素占一个存储单元，采用以行为主序的方法存放,求任意元素ajk的地址计算公式为:

```c
Loc(A[i][j][k])=Loc(A[1][1][1]+((i-1)*m*n+(i-1)*n+(k-1)) * size
```

n维数组的地址计算

==肝不动了==

## 5.3特殊矩阵的压缩存储

特殊矩阵压缩存储的压缩原则是:对有规律的元素和值相同的元素只分配一个存储单元，对于零元素不分配空间。

### 5.3.1规律分布的特殊矩阵

#### 5.3.1.1三角矩阵

下三角矩阵:若当i<j时，有aij=c（典型情况c=0)

上三角矩阵:若当i>j时，有aij=c（典型情况c=O)

对称矩阵:若矩阵中的所有元素均满足aij=aji

对于下三角矩阵，按“行序为主序”进行存储，得到的序列为: a11,a21,a22,a31,a32,a33... an1,an2... ann由于下三角矩阵的元素个数为n(n+1)/2，所以可压缩存储到一个大小为n(n+1)/2的- -维数组中。下三角矩阵中元素ai(i>j)，在一维数组A中的地址为:

```c
LOC[i,j]= LOC[1,1] + (i*(i - 1)/2+ j - 1) * size
```

同样，对于上三角矩阵，也可以将其压缩存储到一个大小为n(n+1)/2的一维数组C中。其中元素ai i(i<ij)在数组C中的存储地址为:

```c
LOC[i,j]= LOC[1,1]+(j*(j-1)/2+ i-1)*size
```

对于对称矩阵，因其元素满足aij=aji ,我们可以为每一对相等的元素分配一个存储空间，即只存下三角(或上三角)矩阵，从而将n2个元素压缩到n(n+1)/2个空间中。

#### 5.3.1.2带状矩阵

带状矩阵:在矩阵A中，所有的非零元素都集中在以主对角线为中心的带状区域中。最常见的是三对角带状矩阵.
$$
A(n\times n)=  
\begin{bmatrix}
a_{11} & a_{12} &   &   &   &   \\
a_{21} & a_{22} & a_{23} &  &   &   \\
  & a_{32} & a_{33} & a_{34} &   &   \\
  &   & a_{43} & a_{44} & a_{45} &   \\
  &   &   & \cdots & \cdots & \cdots \\
  \end{bmatrix}
$$
三对角带状矩阵的压缩存储,以行序为主序进行存储,并且只存储非零元素其方法为

1.确定存储该矩阵所需的一维向量空间的大小从三对角带状矩阵中可看出:除第一行和最后一行只有两个元素外，其余各行均有3个非零元素。由此可得到一维向量所需的空间大小为:3n-2。

2.确定非零元素在一维数组空间中的地址

```c
Loc(A[i][j])= Loc(A[1][1])+(3(i-1 )- 1 +j - i +1) * size = Loc(A[1][1])+(2(i-1)+ j-1) * size
```



### 5.3.2 稀疏矩阵

稀疏矩阵:指矩阵中大多数元素为零的矩阵。一般地,当非零元素个数只占矩阵元素总数的25%~30%,或低于这个百分数时，我们称这样的矩阵为稀疏矩阵。
$$
A(n\times n)=  
\begin{bmatrix}
0 & 0 &  0 &0   & 0  & -4  \\
0 & 0 & -4 & 0 &  0 & 0  \\
0  & 0 & 0 & -8 & 0  & 0  \\
 0 &  -23 & 0 & 0 & 0& 0  \\
 0 & 0  &  0 & 0&-9& 0 \\
  \end{bmatrix}
$$

#### 稀疏矩阵的三元组表表示法

对于稀疏矩阵的压缩存储要求在存储非零元素的同时，还必须存储该非零元素在矩阵中所处的行号和列号。我们将这种存储方法叫做稀疏矩阵的三元组表示法。
每个非零元素在一维数组中的表示形式如图所示:

|         row          |         col          |       value        |
| :------------------: | :------------------: | :----------------: |
| 该非零元素所在的行值 | 该非零元素所在的列值 | 该非零元素所在的值 |

```c
#define MAXSIZE 1000
typedef struct
{
    int row,col;
    ElementType e;
}
Triple;
typedef struct
{
    Triple data[MAXSIZE+1];
    int m, n, len;
}TSMatrix;
```

##### 用三元数组表实现稀疏矩阵的转置运算

矩阵转置:指变换元素的位置，把位于(row,col)位置上的元素换到( col ，row)位置上，
也就是说,把元素的行列互换。
采用矩阵的正常存储方式时，实现矩阵转置的经典算法如下:

```c
Void TransMatrix (ElementType source[n][m], ElementType dest[m][n])
{													/*Source和dest分别为被转置的矩阵和转置后的矩阵（用二维数组表示)*/
    int i, j;
        for(i=0;i<m;i++)
            for (j=o;j< n;j++)
                dest[i][j]=source[j][i];
}
```

实现转置的简单方法:
①矩阵source的三元组表A的行、列互换就可以得到B中的元素
②为了保证转置后的矩阵的三元组表B也是以“行序为主序”进行存放，则需要对行
列互换后的三元组B，按B的行下标(即A的列下标)大小重新排序,但排序时间开销较大。
两种处理转置算法:

**方法一:列序递增转置法**

算法思想:
按三元组表A的列序（即转置后的行号从1-A.n)递增的顺序转置，当行号为1扫描A三元组，找出列号为1的所有元素，再行号为2以此类推，直到所有行号全部完成。

```c
void TransposeTSMatrix(TSMatrix A,TSMatrix *B)
{				/*把矩阵A转置到B所指向的矩阵中去。矩阵用三元组表表示*/
    int i , j, k ;
    B->m= A.n ; 
    B->n= A.m ;
    B->len= A.len ;
    if(B->len>0)
        {
            j=1;
            for(k=1; k<=A.n; k++)
                for(k=1; k<=A.len; i++)
                    {
                        B->data[j].row=A.data[i].col;
                         B->data[j].col=A.data[i].row;
                         B->data[j].e=A.data[i].e;
                        j++;
                    }
        }
}
```



**方法二:一次定位快速转置法**

算法思想:
要提高算法性能，应通过一重循环完成转置,即，对A中所有非零元“一次定位”直接放到B三元组表的正确位置。故需要设置num[ ]和position[ ]两个数组，存放如下预先计算的值，以实现一次定位。

num[col]存放A三元组第col列非零元素个数。

position[col]存放A三元组第col列中第一个非零元素的位置。

```c
FastTransposeTSMatrix (TSMatrix A,TSMatrix*B)
{			/*基于矩阵的三元组表示，采用快速转置法，将矩阵A转置为B所指的矩阵*/
    int col ,t , p, q;
    int num[MAXSIZE], position[MAXSIZE];
    B->len= A.len ;
    B->n= A.m ;
    B->m= A.n ;
    if(B->len)
        {
            for(col=1;col<=A.n;col++)
                num[col]=0;
            for(t=1;t<=A.len;t++)
                num[A.data[t].col]++;			               /*计算每一列的非零元素的个数*/
             
            position[1]=1;
            for(col=2;col<A.n;col++)
                position[col]=position[col-1]+num[col-1];
            for(p=1;p<A.len.p++)
                {
                    col=A.data[p].col;
                    q=position[col];
                    B->data[q].row=A.data[p].col;
                    B->data[q].col=A.data[p].row;
                    B->data[q].e=A.data[p].e
                    position[col]++;							/*求col列中下一个非零元素的位置*/
                }
        }
}
```



##### 用三元数组表实现稀疏矩阵的乘法运算

根据数学上矩阵相乘的原理,我们可以得到矩阵相乘的经典算法:

```c
for(i=1;i<=m1;i++)for(j=1;j<=n2;j++)
{
    Q[i][j]=0;
        for(k=1;k<=n1;k++)
            Q[i][j]= Q[i][j]+M[i][k]*N[k][j];
}
```

```c
#define MAXSIZE 1000			/*非零元素的个数最多为1000*/
#define MAXROW 1000					/*矩阵最大行数为1000*/
typedef struct
{
	int row, col;				/*该非零元素的行下标和列下标*/
	ElementTypee;			/*该非零元素的值*/
}Triple;
typedef struct
{
    Triple data[MAXSIZE+1];				/*非零元素的三元组表，data[0]未用*/
    int first[MAXROW+1];				/*三元组表中各行第一个非零元素所在的位置。*/
    int m,n, len;				/*产矩阵的行数、列数和非零元素的个数*/
}TriSparMatrix;
```

```C
int MulSMatrix(TriSparMatrix M,TriSparMatrix N,TriSparMatrix *Q)
{								/*采用改进的三元组表表示法，求矩阵乘积Q=MXN*/
    int arow , brow , p; int ctemp[MAXSIZE];
    if(M.n!=N.m)
        return FALSE;							/*返回FALSE表示求矩阵乘积失败*/
    Q->m=M.m; Q->n=N.n; Q->len=0;
    if(M.len*N.len!=O)
        {
        for(arow=1;arow<=M.m; arow++)							/*逐行处理M*/
            {	
                for(p=1;p<=M.n;p++)
                    ctemp[p]=0 ; *当前行各元素的累加器清零*
                Q->first[arow]=Q->len+1;
                for(p=M.first[arow];p<M.first[arow+1];p++)				/*p指向M当前行中每一个非零元素*/
                {
                    brow=M.data[p].col;							/*M中的列号应与N中的行号相等*/
                    if(brow<N.n)
                        t=N.first[brow+1;
                    else 
                        t=N.len+1;
                    for(q=N.first[brow];q<t;q++)
                        {
                            ccol=N.data[q].col;					/*乘积元素在Q中列号*/
                            ctemp[ccol]+=M.data[p].e*N.data[q].e;
                        }/*for q */         /*求得Q中第crow行的非零元*/
                    for(ccol=1;ccol<Q->n; col++)*压缩存储该非零元*if(ctemp[ccol])
                        {
                            if(++Q->len>MAXSIZE) 
                                return 0;
                            Q->data[Q->len]={arow, ccol, ctemp[ccol]
                        };
            	}/*if */ 
    		}/*for arow */
    	}/*if*/
    return(TRUE);返回TRUE表示求矩阵乘积成功*/
}
```

#### 稀疏矩阵的链式存储结构:十字链表

==优点==:它能灵活地插入因运算而产生的新的非零元素，删除因运算而产生的新的零元素，实现矩阵的各种运算。
在十字链表中,矩阵的每一个非零元素用一个结点表示,该结点除了(row, col value)以外，还要有两个域:
**right** :用于链接同一行中的下一个非零元素;

**down**:用以链接同一列中的下一个非零元素。

![](https://p.ananas.chaoxing.com/star3/1485_819Q50/a9029b644981608c26cc3c0cc70a835c.png?rw=1485&rh=819&_fileSize=109606&_orientation=1)

**十字链表的结构类型说明**

```c
typedef struct OLNode
{
    int row, col;				/*非零元素的行和列下标*/
    ElementType value;
    struct OLNode* right,*down;				/*非零元素所在行表列表的后继链域*/
}OLNode; * OLink;
typedef struct
{
    OLink * row_head,* col_head;			/*行、列链表的头指针向量*/
    int m,n, len;								/*稀疏矩阵的行数、列数、非零元素的个数*/
}CrossList;
```

【算法思想】
(1)读入稀疏矩阵的行数、列数、非零元素的个数;

(2)动态申请行链表的头指针向量、列链表的头指针向量;

(3)逐个读入非零元素，分别插人行链表、列链表。

```c
CreateCrossList (CrossList *M)
{/*采用十字链表存储结构，创建稀疏矩阵M*/
	scanf(&m,&n,&t);/*输入M的行数,列数和非零元素的个数*/
	M->m=m;
	M->n=n;
	M->len=t;
    if(!(M->row_head=(OLink * )malloc((m+1)sizeof(OLink))))
        exit(OVERFLOW);
    if(!(M->col_head=(OLink * )malloc(n+1)sizeof(OLink))))
        exit(OVERFLOW);
        M->row_head[ ]=M->col_head[ ]=NULL;
                /*初始化行、列头指针向量，各行、列链表为空的链表*/
    for(scanf(&i,&j,&e);i!=0; scanf(&i,&j,&e))
    {
        if((p=(OLNode *) malloc(sizeof(OLNode))))
            exit(OVERFLOW);p->row=i;p->col=j;p->value=e;/*生成结点*/
        if(M->row_head[i]==NULL) M->row_head[i]=p;else
            {				/*寻找行表中的插入位置*/
            for(q=M->row_head[]; q->right&&q->right->col; q=q->right);/*空循环体*/
                p->right=q->right; q->right=p;/*完成插人*/
            }
        if(M->col_head[j]==NULL) M->col_head[]=p;else
            {			/*寻找列表中的插入位置*/
                for(q=M->col_head[il; q->down&&q->down->row<i;q=q->down);/*空循环体*/
                     p->down=q->down; q->down=p/*完成插入*/
            }
	}
}
```



## 5.4广义表

### 5.4.1 广义表的概念

广义表也是线性表的一种推广。广义表也是n个数据元素(d，d2,d3，...，d)的有限序列，但不同的是，广义表中的d,既可以是单个元素,还可以是一个广义表,通常记作: GL=(d1,d2,d3，...，dn) 。GL;是广义表的名字,通常用大写字母表示。n是广义表的长度。若di,是一个广义表，则称di,是广义表GL的子表。在G中,d1,是GL的表头,其余部分组成的表（d2, d3，..d称为GL的表尾。由此可见，广义表的定义是递归定义的。

例如:
SD= ()空表;其长度为零。
A=(a，(b,c))表长度为2的广义表，其中第一个元素是单个数据a,第二个元素是一个子表( b,c)
B=(A，A，D)长度为3的广义表,其前两个元素为表A,第三个元素为空表D。
C= (a,C)长度为2递归定义的广义表，C相当于无穷表C= (a，(a,(a,(...)) ) ) 。
head(A)=a表A的表头是a
tail(A)=((b,c))表A的表尾是((b, c))，广义表的表尾一定是一个表。

从上面的例子可以看出:
(1)广义表的元素可以是子表，而子表还可以是子表...，由此，广义表是一个多层的结构。
(2)广义表可以被其他广义表共享。如:广义表B就共享表A。在表B中不必列出表A的内容，只要通过子表的名称就可以引用该表。
(3)广义表具有递归性，如广义表C。

### 5.4.2 广义表的存储结构

广义表中有两类结点,一类是单个元素结点,一类是子表结点。任何一个非空的广义表都可以将其分解成表头和表尾两部分,反之，一对确定的表头和表尾可以唯一地确定一个广义表。由此,一个表结点可由三个域构成:标志域,指向表头的指针域，指向表尾的指针域。而元素结点只需要两个域:标志域和值域。

![](https://p.ananas.chaoxing.com/star3/origin/fe6a9b123a239fcf411e31d8aec6f3a8.png?rw=1048&rh=802&_fileSize=125665&_orientation=1)

```C
/*广义表的头尾链表存储结构*/
typedef enum(ATOM, LIST} ElemTag;
/*ATOM=0，表示原子;LIST=1，表示子表*/
typedef struct GLNode
{ElemTag tag;
    										/*标志位tag用来区别原子结点和表结点*/
    union
    { AtomType atom;						/*原子结点的值域atom*/
         struct{
             struct GLNode* hp, *tp;
         } htp;								/*表结点的指针域htp包括表头指针域hp和表尾指针域tp*/
    }atom htp;
    /*atom htp是原子结点的值域aton和表结点的指针域htp的联合体域*/
}*GList;
```

在这种结构中，无论是单元素结点还是子表结点均由三个域构成。其结点结构如图所示:

![](https://p.ananas.chaoxing.com/star3/origin/fc078d8e5311bf70c5a3fb31110ae7ed.png?rw=1381&rh=660&_fileSize=72296&_orientation=1)

第二种方法：

```c
typedef enum {ATOM,LIST} ElemTag;
/*ATOM=0，表示原子;LIST=1，表示子表*/
typedef struct GLNode
{
    ElemTag tag;
    union
    {
        AtomType atom;struct GLNode* hp;
    }atom_hp;
    /*atom_hp是原子结点的值域atom和表结点的表头指针域hp的联合体域*/
     struct GLNode* tp;
}*GList
```

### *5.4.3 广义表的操作实现



## 5.5总结与提高

### 主要知识点

#### 1.数组的基本知识点

- n维数组可以看成是每个数据元素均是一个n-1维数组的线性表。
- 数组是一组有固定个数元素的集合。给出维数和每一维的上下限，数组中的元素个数就固定了。
- 数组采用顺序存储结构，主要操作是随机存取,即给定元素的下标，得到该元素在计算机中的存放位置。

#### 2。特殊矩阵的压缩存储

特殊矩阵的特殊性表现在:
(1）元素分布有规律的矩阵。只需找到对应规律的函数,就可由二维矩阵A中元素aj的下标计算出一维内存空间地址值K，实现二维矩阵到压缩存储后的一维数组的存储映射。
(2)非零元素很少的稀疏矩阵，只存非零元素所在的行号，列号及元素值来实现压缩存储

#### 3.广义表

- 广义表是n个元素(d，d，d3,...，dn)的有限序列，di既可以是单个元素，也可以是广义表。广义表的定义具有递归性，其操作通常采用递归实现。
- 一个非空的广义表GL可以看成是由表头和表尾构成。第一个元素称为表头，除表头以外的其余元素构成表尾。
- 常用的存储方式有:头尾链表存储结构和同层结点链存储结构。

### 典型题例

#### 例1应用公式计算地址

已知数组M[1..10,—1..6,0.3]，求出

1. 数组的元素总数
2. 若数组以下标顺序为主序存储,起始地址为1000，且每个数据元素占用3个存储单元
   试分别计算M[2,4,2], M[5,—1,3]的地址。

解:(1)数组的元素总数为;
(10-1+1)×(6-(-1)+1)×(3-0+1)=320

解:(2)地址计算公式为:
LocM[][加[k]= LocM\[c1]\[c2][c3]+((d2-c2十1)×(d3-c3十1)×(i-c1)+(d3-c3十1)×(j-c2)+(k-c3))×size
在此c1=1，d1=10,c2=-1，d2=6，c3=0，d3=3,所以:
LocM\[2]\[4][2]= 1000+((6-(-1)+1)×(3-0十1)×(2-1)+(3-0+1)×(4-(-1))+(2-0))×3=1162



#### 例2上三角矩阵An×n计算地址公式推导

已知，当i>时，aij=c，要求将其压缩存储到一维数组B[1..m]中。请说明压缩存储方法,并给出任意元素aij与B[k]的对应关系:k=f(i, j)。

解:

①上三角中共有n(n+1)/2个元素，下三角中所有
元素相同，所以使用一维数组B[1..n(n+1)/2]。
②上三角中第t行共有n-t+1个元素，所以，对于上三角中任意元素aij而言，排在前面的i-1行中共有元素:i-1
$$
\sum^{i-1}_{t=1}(n-t+1)=\frac{(i-1)(2n-i+2)}2
$$
③解:③上三角的第i行中，排在aj前面的元素数目为
$$
j-(i-1)-1=j-i
$$
所以，对于任意元素aj而言，排在aj前面的元素数目为:
$$
\frac{(i-1)(2n-i+2)}{2}+j-i
$$
因此，上三角中任意元素aj在一维数组B中的位置为:
$$
k=f(i,j)=\frac{(i-1)(2n-i+2)}{2}+j-i+1
$$

综上所述,任意元素aj与B[k]的对应关系为:
$$
当i>j时, k = f(i,j)=m\\
当i\leq j时，k= f(i,j)=\frac{(i-1)(2n-i+1)}{2}+j-i+1
$$


#### 例3求广义表表头与表尾

已知广义表L=((x, y, z),a, (u, t, w))，则head(head(tail(tail(L)))的结果是:

解:

(1)用tail运算去掉表头(x, y,z)，即:
tail(L)=(a, (u, t, w))

(2)再用tail运算去掉表头a，即:
tail(tail(L))= ((u, t, w))

(3)用head运算取出表头(u, t, w)，即:
head(tail(tail(L)))= (u, t, w)

(4）再用head运算取出表头u，即:
head(head(tail(tail(L))))=u

所以head(head(tail(tail(L))))=u



___

# 第6章树和二叉树

## 6.1树的定义与基本术语

### 树的基本概念

==树==是n (n≥0)个结点的有限集合T。当n=O时，称为空树当n>0时，该集合满足如下条件:

- 其中必有一个称为根〈root)的特定结点，它没有直接前驱,但有零个或多个直接后继。
- 其余n-1个结点可以划分成m (m≥0)个互不相交的有限集T1，T2，T3,...，Tm，其中Ti又是一棵树，称为根root的子树。每棵子树的根结点有且仅有一个直接前驱，但有零个或多个直接后继。

![](https://p.ananas.chaoxing.com/star3/origin/8815f0cc17e33f085380a0e8ec0c35d7.png?rw=800&rh=477&_fileSize=35166&_orientation=1)

### 树的图解表示

#### 倒置树结构(树形表示法)

![https://p.ananas.chaoxing.com/star3/origin/8815f0cc17e33f085380a0e8ec0c35d7.png?rw=800&rh=477&_fileSize=35166&_orientation=1](https://p.ananas.chaoxing.com/star3/origin/8815f0cc17e33f085380a0e8ec0c35d7.png?rw=800&rh=477&_fileSize=35166&_orientation=1)

#### 文氏图表示法(嵌套集合形式)

![](https://p.ananas.chaoxing.com/star3/origin/210e65146ccb4ca5341ffe459c12b6b0.png?rw=781&rh=751&_fileSize=67624&_orientation=1)

#### 广义表形式(嵌套括号表示法)

**(A(B(E(K,L),F),C(G),D(H(M),1,J)))**

#### 凹入表示法

![](https://p.ananas.chaoxing.com/star3/origin/ed5dcdc74475c3da07fae0c4f0ffcd1e.png?rw=444&rh=882&_fileSize=31546&_orientation=1)

### 树的相关术语

#### 结点

包括一个数据元素及若干指向其它结点的分支信息。

#### 结点的度

一个结点的子树个数。

#### 叶结点

度为0的结点,即无后继的结点,也称为终端结点。

#### 分支结点

度不为0的结点,称为非终端结点。

#### 孩子结点

一个结点的直接后继称为该结点的孩子结点。

#### 双亲结点

个结点的直接前驱称为该结点的双亲结点。

#### 兄弟结点

同一双亲结点的孩子结点之间互称兄弟结点。

#### 祖先结点

个结点的祖先结点是指从根结点到该结点的路径上的所有结点。

#### 子孙结点

个结点的直接后继和间接后继称为个该结点的子孙结点

#### 树的度

树中所有结点的度的最大值。

#### 结点的层次

从根结点开始定义,根结点的层次为1,根的直接后继的层次为2，依此类推。

#### 树的高度

树中所有结点的层次的最大值。

#### 有序树

在树T中,如果各子树Ti之间是有先后次序的，则称为有序树。

#### 森林

m (m>=0)棵互不相交的树的集合。

### 树的抽象数据类型

ADT Tree {
数据对象D:一个集合,该集合中的所有元素具有相同的特性。

结构关系R:若D为空集,则为空树。若D中仅含有一个数据元素，则R为空集,否则R={H}，H是如下的二元关系:

1. 在D中存在唯一的称为根的数据元素root，它在关系H下没有前驱。
2. 除root以外，D中每个结点在关系H下都有且仅有一个前驱。

(1) InitTree (Tree)           将Tree初始化为一棵空树。

(2) DestoryTree (Tree)	销毁树Tree。

(3) CreateTree (Tree)	创建树Tree。

(4) TreeEmpty (Tree)若树Tree为空,则返回TRUE,否则返回FALSE。

(5) Root (Tree)返回树Tree的根

(6) Parent (Tree，x)树Tree存在，X是Tree中的某个结点。若x为非根结点,则返回它的双亲,否则返回“空”

(7) FirstChild (Tree，x)树Tree存在，X是Tree中的某个结点。若x为非叶子结点,则返回它的第一个孩子结点,否则返回“空”

(8) NextSibling (Tree，x)树Tree存在，X是Tree中的某个结点。若x不是其双亲的最后一个孩子结点,则返回x后面的下一个兄弟结点,否则返回“空”

(9) InsertChild (Tree,p. Child )树Tree存在，p指向Tree中某个结点，非空树Child与Tree不相交。将Child插入Tree中，做p指向结点的子树。

(10)DeleteChild (Tree，p，i)树Tree存在，p指向Tree中某个结点,1=<i<=d,d为p所指向结点的度。删除Tree中p所指向结点的第i棵子树。

(11) TraverseTree (Tree，Visit ( )树Tree存在，Visit()是对结点进行访问的函数。按照某种次序对树Tree的每个结点访问一次且最多一次。若Visit()失败，则操作失败。

## 6.2二叉树

### 6.2.1 二叉树的定义与基本操作

定义:我们把满足以下两个条件的树型结构叫做二叉树（ Binary Tree)

- 每个结点的度都不大于2;
- 每个结点的孩子结点次序不能任意颠倒。

由定义得出:二叉树的每个结点只能含有0、1或2个孩子,且有左右之分。位于左边的孩子叫做左孩子，位于右边的孩子叫做右孩子。



二叉树的基本操作:
(1) Initiate (bt):将bt初始化为空二叉树。

(2) Create(bt):创建一棵非空二叉树bt。

(3) Destory (bt) :销毁二叉树bt。

(4)Empty (bt):若bt为空，则返回TRUE，否则返回FALSE

(5) Root(bt):求二叉树bt的根结点。若bt为空二叉树，则函数返回“空"

(6) Parent (bt,x):求双亲函数。求二叉树bt中结点x的双亲结点。若结点x是二叉树的根结点或二叉树bt中无结点x，则返回“空"

(7) LeftChild (bt,x):求左孩子。若结点x无左孩子或x不在bt中，则返回“空"

(8) RightChild (bt,x):求右孩子。若结点无右孩子或x不在bt中，则返回“空”

(9) Traverse (bt).:遍历操作。按某个次序依次访问二叉树中每个结点一次且仅一次。

(10) Clear (bt):清除操作。将二叉树bt置为空树。

### 6.2.2二叉树的性质

#### 性质1∶

在二叉树的第l层上至多有2~1个结点(i≥1)。证明:
当i=1时，整个二叉树只有一根结点，此时2"1=2°=1，结论成立。假设i=k时结论成立，即第k层上结点总数最多为2k~1个。现证明当i=k+1时，结论成立:
因为二叉树中每个结点的度最大为2，则第k+1层的结点总数最多为第k层上结点最大数的2倍，即2X2k1-2(k+1)1，故结论成立

#### 性质2:

深度为k的二叉树至多有2*-1个结点(k≥1)
证明:
因为深度为k的二叉树，其结点总数的最大值是将二叉树每层上结点的最大值相加，所以深度为k的二叉树的结点总数至多为:
$$
\sum^k_{i=1}
$$
第i层上的最大结点个数=
$$
\sum^k_{i=1}2^{i+1}=2^k-1
$$
故结论成立。

#### 性质3

对任意一棵二叉树T，若终端结点数为no,而其度数为2的结点数为n，则no= n2+1 
证明:
设二叉树中结点总数为n, n为二叉树中度为1的结点总数。因为二叉树中所有结点的度小于等于2，所以有n= no+ n1+n2

设二叉树中分支数目为B，因为除根结点外，每个结点均对应一个进人它的分支，所以有: n=B+1。
又因为二叉树中的分支都是由度为1和度为2的结点发出,所以·分支数目为:B=n1+2n2
整理上述两式可得到: n=B+1=n1+2n2+1
将n= no+ n1+n2代人上式得出no+ n1+n2=n1+2n2+1，整理后得no= n2+1，故结论成立。

#### 满二叉树:

深度为k且有2临-1个结点的二叉树。在满二叉树中，每层结点都是满的，即每层结点都具有最大结点数。

![img](https://p.ananas.chaoxing.com/star3/origin/83bcf6196a3f68361f88e3392e21127d.png?rw=856&rh=465&_fileSize=51099&_orientation=1)



#### 完全二叉树:

满二叉树必为完全二叉树,而完全二叉树不一定是满二叉树。

![](https://p.ananas.chaoxing.com/star3/origin/72fb6f48f7b036b77576c6600ca0e7a7.png?rw=834&rh=541&_fileSize=53418&_orientation=1)

#### 性质4:

具有n个结点的完全二叉树的深度为[log2n]+1.

证明:

设n个结点的完全二叉树的深度为k，根据性质2可知,
k-1层满二叉树的结点总数为:2^{k-1}-1
k层满二叉树的结点总数为:2^k-1显然有:
$$
2^{k-1} \leq n < 2^k-1  \Rightarrow  2^{k-1} \leq n \leq 2^k
$$
取对数有: 
$$
k-1\leq log_2n<k
$$
因为k是整数，所以k-1=log2n， k=[log2n]+1结论成立。



#### 性质5:

对于具有n个结点的完全二叉树,如果按照从上到下和从左到右的顺序对二叉树中的所有结点从1开始顺序编号,则对于任意的序号为i的结点有:

1. 若i=1,则i无双亲结点  若i >1,则i的双亲结点为[i /2]
2. 若2\*i>n,则i无左孩子  若2\*≤n,则i结点的左孩子结点为2\*3
3. 若2\*ti+1 > n ,则i无右孩子  若2\*i+1≤n,则i的右孩子结点为2*i+1

用归纳法证明其中的(2)和(3)。

### 6.2.3二叉树的存储结构

二叉树的结构是非线性的，每一结点最多可有两个后继。

二叉树的存储结构有两种:顺序存储结构和链式存储结构。

#### 顺序存储结构

顺序存储结构:是用一组连续的存储单元来存放二叉树的数据元素(数组下标从1开始)。

![](https://p.ananas.chaoxing.com/star3/origin/5715d0c1d88a218d64bf5169c5baba0a.png?rw=1203&rh=669&_fileSize=115341&_orientation=1)

对于一般的二叉树，我们必须按照完全二叉树的形式来存储，就会造成空间的浪费。单支树就是一个极端情况

![](https://p.ananas.chaoxing.com/star3/origin/7fd25d54692080b5d26fd8c5b0fa898e.png?rw=1274&rh=600&_fileSize=89780&_orientation=1)



#### 链式存储结构

对于任意的二叉树来说，每个结点只有两个孩子,一个双亲结点。我们可以设计每个结点至少包括三个域:数据域、左孩子域和右孩子域:

![](https://p.ananas.chaoxing.com/star3/origin/a9bc40d3611dccab815307b2f90dc774.png?rw=1267&rh=577&_fileSize=115008&_orientation=1)

二叉树的二叉链表结点的结构用C语言描述为:

```c
typedef struct Node
{
    DataType
    data:
    struct Node* LChild;struct Node * RChild;
}BiTNode, *BiTree;
```


有时，为了找到父结点，可以增加一个Parent域,Parent域指向该结点的父结点。该结点结构如下:

| LChild | Data | Parent | RChild |
| ------ | ---- | ------ | ------ |
|        |      |        |        |



结论:
若一个二叉树含有n个结点,则它的二叉链表中必含有2n个指针域,其中必有n十1个空的链域。
证明结论:
分支数目:B=n-1,
即非空的链域有:n-1个,
故空链域有: 2n-(n-1)=n+1个。

## 6.3二叉树的遍历与线索化

### 6.3.1二叉树的遍历

#### 1.遍历的概念

##### 1.二叉树定义

n >=0个有限结点构成的集合

n= 0为空二叉树;

n > 0的二叉树由一个根结点和分别称为左右子树的两个互不相交的二叉树构成。

##### 2.二叉树的二叉链表存储结构

二叉树由根、左子树和右子树构成:

##### 二叉树的遍历作用:

**遍历含义**:指按一定规律对二叉树中的每个
结点访问且仅访问一次。

**遍历目的:**将非线性化的树变成线性化结构

#### 2.遍历规律与递归算法

用L、D、R分别表示遍历左子树、访问根结点、遍历右子树二叉树拍的遍历顺序有:
(1)访问根，遍历左子树，遍历右子树(记做DLR)
(⑵)访问根，遍历右子树，遍历左子树(记做DRL)
(3)遍历左子树，访问根，遍历右子树(记做LDR)
(4)遍历右子树，访问根，遍历左子树(记做RDL)
(5)遍历左子树，遍历右子树，访问根(记做LRD)
(6)遍历右子树，遍历左子树，访问根(记做RLD)

##### 先序遍历（DLR）操作过程

若二叉树为空，则空操作否则依次执行如下操作:

1. 访问根结点;
2. 按先序遍历左子树;
3. 按先序遍历右子树。

```C
void PreOrder(BiTree root)
{
    if (root!=NULL)
    {
        Visit(root ->data);
        PreOrder(root ->LChild);PreOrder(root ->RChild);
    }
}
```

![](https://p.ananas.chaoxing.com/star3/origin/a252b89e57a8f07500b66f958f43e017.png?rw=645&rh=459&_fileSize=71592&_orientation=1)

##### 中序遍历（LDR）操作过程

若二叉树为空，则空操作否则依次执行如下操作:

1. 按中序遍历左子树;
2. 访问根结点;
3. 按中序遍历右子树。

```c
void InOrder(BiTree root)
{
    if (root!=NULL)
    {
    	lnOrder(root ->LChild);
        Visit(root ->data);
        InOrder(root ->RChild);
    }
}
```

![](https://p.ananas.chaoxing.com/star3/origin/09db4e235b0944721eddd07da6e03147.png?rw=615&rh=451&_fileSize=69204&_orientation=1)

##### 后序遍历（LRD）操作过程

若二叉树为空，则空操作否则依次执行如下操作:

1. 按后序遍历左子树;
2. 按后序遍历右子树;
3. 访问根结点。

```c
void PostOrder(BiTree root)
{
    if(root!=NULL)
        {
            PostOrder(root ->LChild);
            PostOrder(root ->RChild);
            Visit(root ->data);
        }
}
```

![](https://p.ananas.chaoxing.com/star3/origin/9792fdcfbea1a0ca236672ea687c1169.png?rw=629&rh=478&_fileSize=67962&_orientation=1)

##### Sum UP!

先序遍历:ABD FGCEH
中序遍历:BFDGACEH
后序遍历:FGDBHECA

![](https://p.ananas.chaoxing.com/star3/origin/16fdd4617411cf07c7af3bc069c561f1.png?rw=584&rh=429&_fileSize=24982&_orientation=1)

### 6.3.2遍历算法应用

二叉树的遍历运算是一个重要的基础。
注意:

1. 是重点理解访问根结点操作的含义
2. 是对具体问题需要考虑遍历的次序



#### 1.输出二叉树中的结点

思路:按先序遍历走遍二叉树中的每一个结点，并输出。

```c
void PreOrder(BiTree root)
{
    if (rootl=NULL)
    {
    	printf(" %c",root->data);
        PreOrder(root ->LChild);
        PreOrder(root ->RChild);
    }
}
```



#### ⒉输出二叉树中的叶子结点

思路:在遍历过程中判断当前访问结点是否为叶子结点条件:既没有左孩子，又没有右孩子的是叶子结点

```c
void PreOrder(BiTree root)
{
    if (rootl=NULL)
        {
        if(root->LChild==NULL && root->RChild==NULL)
            printf("%c",root->data);
        PreOrder(root ->LChild);PreOrder(root ->RChild);
    	}
}
```

![](https://p.ananas.chaoxing.com/star3/origin/e45fc18c1e74c0f898aaba4f66b0c698.png?rw=615&rh=564&_fileSize=96382&_orientation=1)



#### 3.统计叶子结点数目

方法一:设置计数器为全局变量，保存叶子结点数目,
调用之前初值为0。

```c

void leaf(BiTree root)/*后序遍历记数统计叶子结点数目*/
{
    if (root!=NULL)
        {
            leaf(root->LChild);
            leaf(root->RChild);
            if (root ->LChild==NULL && root ->RChild==NULL)
                LeafCount++;
        }
}
```



方法二按递归函数方式求解计算

```c
/*采用递归算法，如果是空树，返回0;如果只有一个结点，返回1;否则为左右子树的叶子结点数之和*/
int leaf(BiTree root)/*后序遍历递归返值统计叶子结点数目*/
{
    int LeafCount;
    if(root==NULL)
        LeafCount =0;
    else if(root->LChild==NULL)&&(root->RChild==NULL))
    	LeafCount =1;
    else
    	LeafCount =leaf(root->LChild)+leaf(root->RChild);		/*叶，数为左右子树的叶子数目之和*/
    return LeafCount;
}
```





#### 4.建立二叉链表方式存储的二叉树

通常用特定的元素表示空子树。(如用小圆点表示空子树)

给定一棵二叉树  ==>  得到它的扩展前序遍历序列

给定前序遍历序列  <==  创建相应的二叉树

```c
void CreateBiTree(BiTree *bt)
{
    char ch;
    ch=getchar();
    if(ch=='.') *bt=NULL;else
    {
        *bt=(BiTree)malloc(sizeof(BiTNode));
    	(*bt)->data=ch;
    	CreateBiTree(&((*bt)->LChild));
        reateBiTree(&((*bt)->RChild));.
    }
}
```



#### 5.求二叉树的高度

设函数表示二叉树bt的高度，则递归定义如下

若bt为空，则高度为0
若bt非空，其高度应为其左右子树高度的最大值加1

```c
/*后序遍历求二叉树的高度递归算法*/	
int PostTreeDepth(BiTree bt)		
{
    int hl,hr,max;
    if(bt!=NULL)
        {
            hl=PostTreeDepth(bt->LChild);		/*求左子树的深度*/
            hr=PostTreeDepth(bt->RChild);		/*求右子树的深度*/
                max=hl>hr?hl:hr;			/*得到左、右子树深度较大者*/
                return(max+1);        			/*返回树的深度*/
        }
    else 
        return(O);								/*如果是空树则返回0*/
}
```

```c
void PreTreeDepth(BiTeee bt, int h)			/*h为bt指向结点所在层次，初值为1*/
/*depth为当前求得的最大层次,为全局变量，初值为0*/
{
    if(bt!=NULL)
    {
    	if(h>depth)
            depth = h;							/*如果该结点层次值大于depth，更新depth的值*/
        PreTreeDepth(bt->Lchild, h+1);				/*产遍历左子树*/
        PreTreeDepth(bt->Rchild, h+1);				/*遍历右子树*/
    }
}
```



#### 6.按树状打印的二叉树

问题:二叉树中以二叉链表存储,每个结点所含数据元素均为单字母，要求实现如下图的打印结果。

![](https://p.ananas.chaoxing.com/star3/origin/853a9a420f2db0bcaadf7982c99d388e.png?rw=884&rh=289&_fileSize=32391&_orientation=1)

分析:这是二叉树的横向显示问题，
横向显示应是竖向显示的90°旋转
二叉树的横向显示算法一定是中序遍历算法所以把横向显示的二叉树算法改为RDL结构实现算法:

```c
void PrintTree(TreeNode Boot,int nLayer)
/*横向树状打印的二叉树*/
{
    if(Boot= =NULL) 
        return;
    PrintTree(Boot->RChild,nLayer+1);
    for(int i=O;i<nLayer;i++)
		printf(“ ”);
	printf(“%cln”,Boot->ch);
	PrintTree(Boot->LChild ,nLayer+1);
}
```





#### 练习

对二叉树从1开始编号，要求每个结点的编号大于其左右孩子的编号，同一个结点的左右孩子中，其左孩子的编号小于其右孩子的编号，则可采用何种遍历方式实现编号?

==后序遍历==

### 6.3.3基于栈的递归消除

递归转换到非递归的原因:

- 递归的执行效率低;
- 运行环境没有递归机制。

递归转化的两种方法:
直接尾递归   可化为直线型 用循环替代递归递归
复杂情况  采用工作栈消除递归

在大量复杂的情况下，递归的问题无法直接转换成循环,需要采用工作栈消除递归。
将递归中系统隐含的栈 ==> 用户自己操纵的栈
工作栈提供一种控制结构
递归进层时，需保留信息 **递归进层的三件事**
递归退层时，需恢复信息 **递归退层的三件事**
示例:

**递归进层三件事:**

1. 保存本层参数,返回地址;
2. 传递参数,分配局部数据空间
3. 控制转移。

递归退层三件事:

1. 恢复上层
2. 传递结果
3. 转断点执行。

？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？



### 6.3.4线索二叉树

#### 基本概念

二叉树的遍历运算是将二叉树中结点按一定规律线性化的过程。不能直接得到结点在遍历序列中的前驱和后继信息。

求解方法一

将二叉树遍历一遍，在遍历过程中便可得到结点的前驱和后继，但这种动态访问浪费时间。

求解方法二

充分利用二叉链表中的空链域，将遍历过程中结点的前驱、后继信息保存下来。

问题:n个结点的二叉树中有多少个空链域?

解答:n个结点的二叉树中共有2n个链域

其中n-1个非空链域,n+1个空链域。

可利用空链域存放前驱和后继信息。

线索:在这种存储结构中,指向前驱和后继结点的指针叫做线索。
线索链表:以这种结构组成的二叉链表作为二叉树的存储结构，叫做线索链表。
线索化:对二叉树以某种次序进行遍历并且加上线索的过程叫做线索化。
线索二叉树:线索化了的二叉树称为线索二叉树。





#### 二叉树的线索化

线索化是在遍历过程中修改空指针域的过程。
对二叉树按照不同的遍历次序进行线索化,可以得到先序、中序、后序线索二叉树。

示例

![](https://p.ananas.chaoxing.com/star3/origin/72b9fdb446874822e15ec5c1f020b854.png?rw=651&rh=602&_fileSize=30974&_orientation=1)

![img](https://p.ananas.chaoxing.com/star3/origin/8c781f9de73ea239f10099cc01186827.png?rw=700&rh=515&_fileSize=27390&_orientation=1)

![](https://p.ananas.chaoxing.com/star3/origin/7c1f08e9daecd41e3f0fa7cbbe54065e.png?rw=754&rh=639&_fileSize=36440&_orientation=1)



中序线索化算法思路:(按中序遍历规则)

| 当前访问结点root |      | root的前驱结点pre |
| ---------------- | ---- | ----------------- |
| root无左         | ==>  | pre为root的前驱   |
| root为pre的后继  | <==  | pre无右           |


```c
void lnthread(BiTree root)
/*对root所指的二叉树进行中序线索化，其中pre始终指向刚访问过的结点，其初值为NULL*/
{
        if (root!=NULL)
    		{
                lnthread(root->LChild);        					/*线索化左子树*/
                if (root->LChild==NULL)
                {
                    root->Ltag=1; 
                    root->LChild=pre;				/*置前驱线索*/
                }
                if (pre!=NULL&& pre->RChild==NULL)                /*置后继线索*/
                	pre-> RChild=root;
                pre->Rtag=1;
                pre=root;
                Inthread(root->RChild);           				 /*线索化右子树*/
    		}
}
```





#### 在线索二叉树中找前驱、后继结点

中序找前驱

![img](https://p.ananas.chaoxing.com/star3/origin/a4a361385a1353cbf2d0ffde3d947e31.png?rw=1117&rh=677&_fileSize=154068&_orientation=1)

```c
void InPre(BiTNode * p, BiTNode * pre)/*在中序线索二叉树中查找p的中序前驱,并用pre指针返回结果*/
{
    if(p->Ltag==1)
        pre= p->LChild;								/*直接利用线索*/
    else
    {
        for(q= p->LChild;q->Rtag==0;q=q->RChild)
            pre=q;        						/*在p的左子树中查找“最右下端”结点*/
	}
}
```



中序找后继

![](https://p.ananas.chaoxing.com/star3/origin/d00f355135c3c5c4de67dc859063c53f.png?rw=1138&rh=720&_fileSize=84253&_orientation=1)

```c
void InSucc(BiTNode * p, BiTNode *succ)
/*在中序线索二叉树中查找p的后继结点，并用succ指针返回结果*/
{
    if (p->Rtag==1)
        succ= p-> RChild;/*直接利用线索*/
    else {/*在p的右子树中查找“最左下端”结点*/
        for(q= p->RChild; q->Ltag==0 ;q=q->LChild )
            succ=q;
    	}
}
```



先序找后继

![img](https://p.ananas.chaoxing.com/star3/origin/f5e24f5dec1b750c2f62b13ed7f22e2b.png?rw=1126&rh=747&_fileSize=77652&_orientation=1)



后序找前驱

![](https://p.ananas.chaoxing.com/star3/origin/acd9a9f525a29a016fbadb957b8b7e38.png?rw=1128&rh=723&_fileSize=76495&_orientation=1)

先序找前驱

![](https://p.ananas.chaoxing.com/star3/origin/00a614c7bec7c5c6b5a248ae836f76b6.png?rw=1193&rh=729&_fileSize=68894&_orientation=1)

![](https://p.ananas.chaoxing.com/star3/origin/a45dc40f6ff555bf5357abdd1d867722.png?rw=1209&rh=727&_fileSize=73536&_orientation=1)

![](https://p.ananas.chaoxing.com/star3/origin/3d1178fb7a9fcadb455af0941bd373fc.png?rw=1307&rh=705&_fileSize=88013&_orientation=1)





#### 线索二叉树的插入、删除运算

二叉树加上线索之后，当插入或删除一结点时,可能会破坏原树的线索。所以在线索二叉树中插入或删除结点的难点在于:插人一个结点后,仍要保持正确的线索。
我们主要以==中序线索二叉树==为例，说明线索二叉树的插入和删除运算。

在中序线索二叉树中插入结点可分为两种情况:
第一种:将新的结点插入到二叉树中,作某结点的左孩子;
第二种:将新的结点插入到二叉树中,作某结点的右孩子。

我们仅讨论后一种情况。
InsNode(BiTNode * p, BiTNode *r)表示在线索二叉树中插人r所指向的结点，做p所指结点的右孩子。

若结点p的右孩子为空，则插入结点r的过程很简单。原来p的后继变为r的后继,结点p变为r的前驱,结点r成为p的右孩子。结点r的插入对p原来的后继结点没有任何的影响。
结点的右孩子为空时的插人过程为:

![](https://p.ananas.chaoxing.com/star3/origin/90b7a7ccc4c78d5883c2577d16b0f353.png?rw=1292&rh=490&_fileSize=86324&_orientation=1)



若p的右孩子不为空，则插人后，p的右孩子变为r的右孩子结点，p变为r的前驱结点，r变为p的右孩子结点。这时还需要修改原来p的右子树中最左下端结点的左指针域，使它由原来的指向结点p变为指向结点r。插人过程为:

![](https://p.ananas.chaoxing.com/star3/origin/e884dc8f3f6986c4e5320baaebe409e0.png?rw=1318&rh=588&_fileSize=47823&_orientation=1)

```c
上述过程用C语言描述为:
void InsNode(BiTNode * p，BiTNode * r)
{
    if(p->Rtag==1)/*p无右孩子*/
        {
            r->RChild=p->RChild;/*p的后继变为r的后继*/
            r->Rtag=1;
            p->RChild=r;/*成为p的右孩子*/
            p->Rtag=0;
            r->LChild=p;/*p变为r的前驱*/
            r->Ltag=1;
        }
    else /*p有右孩子*/
    	{
            s=p->RChild;
        	while(s->Ltag==O)
            	s=s->LChild;		/*查找p结点的右子树的“最左下端”结点*/
            r->RChild=p->RChild;		/*p的右孩子变为r的右孩子*/
            r->Rtag=0;
            r->LChild=p; 				/*p变为r的前驱*/
            r->Ltag=1;
            p->RChild=r;					/*r变为p的右孩子*/
            s->LChild=r;			/*r变为p原来右子树的最左下端”结点的前驱*/
    	}
}
```



##### 2) 删除结点运算

与插入操作一样，在线索二叉树中删除一个结点也会破坏原来的线索，所以需要在删除的过程中保持二叉树的线索化。
![](https://p.ananas.chaoxing.com/star3/origin/6b717f8d2a5f851f030ddfb9b23fb9c0.png?rw=1276&rh=446&_fileSize=34377&_orientation=1)



### 6.3.5由遍历序列确定二叉树

从二叉树的遍历可知,任意一棵二叉树的前序遍历和中序遍历是唯一的。那么,给定结点的前序序列和中序序列，能否确定一棵二叉树呢?
二叉树的前序序列中,第一个结点必是根D;根结点D可将中序序列分成两部分:D之前是左子树的中序序列,D之后是右子树的中序序列。再根据左子树的中序序列，又可将前序序列除根以外分成左子树的前序序列和右子树的前序序列。依次类推,便可递归得到整棵二叉树。



结论:给定一棵二叉树的刖序序列和十厅小>,唯一确定一棵二叉树。
例:已知结点的前序序列和中序序列分别为:
前序序列:18 14 7 3 11 22 36 27
中序序列:3 7 11 14 18 22 27 35
则可按上述分解求得整棵二叉树。

![img](https://p.ananas.chaoxing.com/star3/origin/db7a83e48e7846b38916bdc786e9a76d.png?rw=1352&rh=845&_fileSize=115551&_orientation=1)

## 6.4树、森林和二叉树的关系

### 6.4.1 树的存储结构

树的主要存储方法有:

#### 双亲表示法

双亲表示法:用一组连续的空间来存储树中的结点，在保存每个结点的同时附设个指示器来指示其双亲结点在表中的位置

![](https://p.ananas.chaoxing.com/star3/origin/0b6052e8efa393c74ddb4fa27808d7de.png?rw=670&rh=466&_fileSize=29566&_orientation=1)

双亲表示法的==优点==:
利用了树中每个结点(根结点除外)只有一个双亲结点的性质，使得
查找某个结点的双亲结点非常容易。

双亲表示法的==缺点==:
在求某个结点的孩子时，需要遍历整个向量。

#### 孩子表示法

孩子表示法:通常是把每个结点的孩子结点构成一个单链表,称为孩子链表。n个结点共有n个孩子链表,而n个结点的数据和n个孩子链表的头指针又组成一个顺序表。

![img](https://p.ananas.chaoxing.com/star3/origin/84a9fc3811e0f9ea85a58a4595ba80e3.png?rw=1016&rh=425&_fileSize=43808&_orientation=1)

```c
typedef struct ChildNode									/*孩子链表结点的定义*/
{
int Child;									/*该孩子结点在线性表中的位置*/
struct ChildNode * next;					/*指向下一个孩子结点的指针*/
}ChildNode;

typedef struct						/*顺序表结点的结构定义*/
{
    DataType data;						/*结点的信息*/
    ChildNode * FirstChild ;		/*指向孩子链表的头指针*/
}DataNode;

typedef struct					/*树的定义*/
{
    DataNode nodes[MAX;			/*顺序表*/
    int root,num;			/*该树的根结点在线性表中的位置和该树的结点个数*/
}ChildTree;
```





#### 孩子兄弟表示法

孩子兄弟表示法(二叉链表表示法):链表中每个结点设有两个链域，分别指向该结点的第一个孩子结点和下一个兄弟(右兄弟结点。

```c
typedef struct CSNode
{
    DateType date; 					/*结点信息*/
    Struct CSNode *FirstChild,*Nextsibling;			/*第一个孩子，下一个兄弟*/
}CSNode, *CSTree;
```

![img](https://p.ananas.chaoxing.com/star3/origin/eb892350631c84ae6e1c1c9caed1dc0f.png?rw=1301&rh=727&_fileSize=114049&_orientation=1)



### 6.4.2 树、森林与二叉树的相互转换

#### 1.树转换为二叉树

方法:

1. 树中所有相邻兄弟之间架一条连线。
2. 对树中的每个结点,只保留其与第一个孩子结点之间的连线,删去其与其他孩子结点之间的连线。
3. 以树的根结点为轴心,将整棵树顺时针旋转一定的角度，使之结构层次分明。

![](https://p.ananas.chaoxing.com/star3/origin/7233577a9a815666a536aa85722dd1a2.png?rw=1293&rh=384&_fileSize=107090&_orientation=1)

通过转换过程可以看出，树中的任意一个结点都对应于二叉树中的一个结点。
树中某结点的第一个孩子在二叉树中是相应结点的左孩子，树中某结点的右兄弟结点在二叉树中是相应结点的右孩子。
也就是说，在二叉树中，左分支上的各结点在原来的树中是父子关系,而右分支上的各结点在原来的树中是兄弟关系。由于树的根结点没有兄弟,所以变换后的二叉树的根结点的右孩子必然为空。

![](https://p.ananas.chaoxing.com/star3/origin/e29c00398b0031e5c8bf2d84d9406343.png?rw=1337&rh=773&_fileSize=210518&_orientation=1)

#### 2.森林转换为二叉树

![](https://p.ananas.chaoxing.com/star3/origin/d051fc844831e49fb44d97a5ca637378.png?rw=1361&rh=769&_fileSize=252119&_orientation=1)





#### 3.二叉树还原为树或森林

1. 若某结点是其双亲的左孩子,则把该结点的右孩子、右孩子的右孩子...都与该结点的双亲结点用线连起来。
2. 删掉原二叉树中所有双亲结点与右孩子结点的连线。
3. 整理所得到的树或森林。

![img](https://p.ananas.chaoxing.com/star3/origin/dcd35a18f96f58e6db0127723d850b2b.png?rw=1327&rh=466&_fileSize=136129&_orientation=1)

### 6.4.3 树与森林的遍历

以先序遍历为例：

森林的先序遍历
若森林非空，则遍历方法为:
(1)访问森林中第一棵树的根结;
(2)先序遍历第一棵树的根结点的子树森林;
(3)先序遍历除去第一棵树之后剩余的树构成的森林。



## 6.5哈夫曼树及其应用

### 6.5.1哈夫曼树

#### 哈夫曼树的基本概念

##### 路径

指从一个结点到另一个结点之间的分支序列。

##### 路径长度

指从一个结点到另一个结点所经过的分支数目。

![](https://p.ananas.chaoxing.com/star3/origin/e0fe089403bf58fe6c0f91dcf38e7863.png?rw=469&rh=384&_fileSize=19447&_orientation=1)

##### 树的路径长度

树中所有结点的路径长度之和为树的路径长度PL

![](https://p.ananas.chaoxing.com/star3/origin/e021ca0070ab9eb930395679a06a6c5d.png?rw=685&rh=400&_fileSize=22751&_orientation=1)

##### 结点的权

给树的每个结点赋予一个具有某种实际意义的实数，我们称该实数为这个结点的权。

##### 带权路径长度

从树根到某一结点的路径长度与该结点的权的乘积,叫做该结点的带权路径长度。

##### 树的带权路径长度

树的带权路径长度为树中所有叶子结点的带权路径长度之和，
通常记为: 
$$
WPL=\sum^n_{i=1}W_i\times l_i
$$
其中n为叶子结点的个数，wi为第i个叶子结点的权值，li为第i个叶子结点的路径长度。

![](https://p.ananas.chaoxing.com/star3/origin/fc8b72287d136553637f513d06671cb9.png?rw=537&rh=432&_fileSize=25356&_orientation=1)

![{{{commingsoon!}}}](https://p.ananas.chaoxing.com/star3/origin/905ccb4a0073546997fd10b35e83731c.png?rw=1446&rh=812&_fileSize=301465&_orientation=1)

![](https://p.ananas.chaoxing.com/star3/origin/df83f101dfeb537883b9b400724c1bac.png?rw=1314&rh=855&_fileSize=220435&_orientation=1)

**==结论:==完全二叉树具有最小路径长度的性质。**

#### 构造哈夫曼树

哈夫曼树的定义

哈夫曼树又叫最优二叉树，它是由n个带权叶子结点构成的所有二叉树中带权路径长度WPL最短的二叉树。

哈夫曼树的构造步骤

- 给定n个权值:{w1, w2, ..., wn},构造森林F={T1,T2, ...., Tn},其中Ti为单根树，根的权值为wi。
- 在森林F中选择两棵根结点权值最小的二叉树，作为一棵新二叉树的左、右子树，标记新二叉树的根结点权值为其左右子树的根结点权值之和。
- 从F中删除选中的那两棵二叉树，同时把新构成的二叉树加人到森林F中。
- 重复()、(3）操作，直到森林中只含有一棵二叉树为止，此时得到的这棵二叉树就是哈夫曼树。



示例:已知权值集合:```{5，2，7，3，8}```构造哈夫曼树

![](https://p.ananas.chaoxing.com/star3/origin/eaba8bce578896fba88a86ddbe04c818.png?rw=829&rh=628&_fileSize=48789&_orientation=1)



#### 哈夫曼树的类型定义

由于哈夫曼树中没有度为1的结点，则一棵有n个叶子的哈夫曼树共有2×n-1个结点，可用一个大小为2×n-1的一维数组来存放各个结点。
每个结点同时还包含其双亲信息和孩子结点信息，构成一个静态三叉链表。

```c
typedef struct{
int weight ;
intparent,LChild，RChild ;
}HTNode，HuffmanTree[M+1];

```



#### 哈夫曼树的算法实现

```c
Huffmantree crt_huffmantree(HuffmanTree ht,int w[],int n
{/*w存放n个字符和指令的权值。*/
    m=2*n-1;
    for(p=ht,i=1;i<=n;i++,p++,W++)
        *p =f*w,0,0,0};
    for(;i<=m;i++,p++)
        *p ={0,0,0,0};/*数组初始化*/
    for(i=n+1;i<=m;i++)
        {
            select(ht,i-1,&s1, &s2);
            /*选择parent为0且weight最小的两个结点，其序号分别赋值给所，s1，s2*/
            ht[s1].parent=i;
            ht[s2].parent=i;
            ht[i].Lchild=s1;
            ht[i].Rchild=s2;
            ht[li].weight=ht[s1].weight+ht[s2].weight;
        }/*哈夫曼树建立完毕*/
}
```

![](https://p.ananas.chaoxing.com/star3/origin/746039420b8357fcd8f0473504609316.png?rw=672&rh=822&_fileSize=65561&_orientation=1)

### 6.5.2哈夫曼编码

#### 哈夫曼编码的概念

前缀码:如果在一个编码系统中，任一个编码都不是其他任何编码的前缀(最左子串)，则称该编码系统中的编码是前缀码。

哈夫曼编码:对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0,右分支赋予1，则从根到每个叶子的通路上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。

##### 哈夫曼编码的相关特性:

定理一:哈夫曼编码是前缀码。
证明:哈夫曼编码是根到叶子路径上边的编码序列,由树的特点知，若路径A是路经B的最左部分，则B经过了A，即A的终点不是叶子。而哈夫曼编码都对应终点为叶子的路径，所以，任一哈夫曼码都不会与其它哈夫曼编码的前部重叠，即哈夫曼编码是前缀码。



定理二:哈夫曼编码是最优前缀码。即哈夫曼编码，能使各种报文（由这n种字符构成的文本）对应的二进制串的平均长度最短
证明:由于哈夫曼编码对应叶权为各字符使用频度的哈夫曼树，因此，该树为带权长度最小的树，即
$$
\sum^n_{i=1}w_ip_i
$$
最小，其中Wi是第i个字符的使用频度，而Pi是第i个字符的编码长度，这正是度量报文的平均长度的式子。



####  哈夫曼编码的作用

哈夫曼树最典型的应用是在编码技术上的应用。利用哈夫曼树，我们可以得到平均长度最短的编码。
例如:设有一台模型机，共有7种不同的指令其使用频率为:

| 指令 | 使用频率（pi) |
| ---- | ------------- |
| I1   | 0.40          |
| I2   | 0.30          |
| I3   | 0.15          |
| I4   | 0.05          |
| I5   | 0.04          |
| I6   | 0.03          |
| I7   | 0.03          |


【问】：若采用定长操作码，需要几位编码?

【答】：需要3位(2^3 = 8) 。



为了减少程序总位数，可采用变长编码。问]:下面的变长编码是否可行?

| 指令  | 使用频率（pi)   |
| ---- | ------------- |
| I1   | 0             |
| I2   | 1             |
| I3   | 00            |
| I4   | 01            |
| I5   | 000           |
| I6   | 001           |
| I7   | 010           |

【答】：不行，因为机器无法解码。

如对编码串0010110该怎样识别呢?
第一个0可以识别为l,也可以和第二个0组成的00一起被识别为 l3。



==【结论】==：变长编码必须满足条件:

任意一个编码不能成为其它任意编码的前缀。我们把满足这个条件的编码叫做前缀编码。



**利用哈夫曼算法，我们可以设计出最优的前缀编码。首先以每条指令的使用频率为权值构造哈夫曼树**

若规定:
向左的分支标记为1,向右的分支标记为0.

从根结点开始，走到叶结点,所经过的代码序列，就构成了相应指令的哈夫曼编码。

![](https://p.ananas.chaoxing.com/star3/origin/8f625a3f24a31c2069f6c1d64757ff78.png?rw=688&rh=492&_fileSize=44445&_orientation=1)

对应的编码表：

| 指令  | 使用频率（pi)   |
| ---- | ------------- |
| I1   | 0             |
| I2   | 10            |
| I3   | 110           |
| I4   | 11100         |
| I5   | 11101         |
| I6   | 11110         |
| I7   | 11111         |

若一段程序有10000条指令，其中l1有400条，I2有300条，l1:有150条，l3有150条，l4有50条，l5有40条，l6有30条，l7有30条，则:
定长编码:程序总位数为:

3×1000= 3000

哈夫曼编码:程序总位数为:
1×400+ 2x300+ 3×150+5×(50+40+30+30)=2200

哈夫曼编码的平均码长为:

0.4



0.4×1+0.3×2+0.15×3+(0.05+0.04+0.03+0.03)×5=2.20

问题描述:数据传送中的二进制编码。要传送数据state，seat,act,cat，set,a，cat，如何使传送的长度最短。

构造满足哈夫曼编码的最短最优性质:

(1）若di≠dj(字母不同)，则对应的树叶不同。因此前缀码(任一字符的编码都不是另一个字符编码)不同，一个路径不可能是其他路径的一部分，所以字母之间可以完区别。
(2)将所有字符变成二进制的哈夫曼编码,使带权路径长度最短，相当总的通路长度最短。





#### 哈夫曼编码的算法实现

```c
/*从叶子结点到根逆向求每个字符或者指令的哈夫曼编码*/
hc=(haffmancode)malloc(n*sizeof(char *);
/*分配n个字符编码的头指针*/
cd=(char*)malloc(n * sizeof(char ));
cd[n-1]='\0';/*编码结束符*/
	for(i=o;j<n;j++)
         {
         start=n-1;
         for(c=j;f=ht[i].parent;f!=O;c=f,f=ht[f].parent)		/*从叶子到根结点求编码*/
             if(ht[f].Lchild-c)
             	cd[--start]='0';
             else 
             	cd[--start]='1';
         hc[j]=(char*)malloc((n-start)*sizeof(char));/*为第j个指令编码分配空间*/
         strcpy(hc[j],&cd[start]);
         }
free(cd);
}

```





## 6.6并查集与等价类划分

### 并查集

实际中经常用到一组互不相交的子集，并且经常需要对其进行如下两个操作:（1确定一个元素所在的子集，(2）合并两个子集。于是人们提出了一个抽象数据类型——并查集。
并查集是一种树型的数据结构，用于处理一些不相交集合(Disjoint Sets）的合并及查询问题。
集就是让每个元素构成一个单元素的集合，并就是按一定顺序将属于同一组的元素所在的集合合并。

以用多种方法实现集合，如位向量、有序表等，根据并查集操作的特点，在此我们采用树结构表示集合。树中每个结点对应集合中的一个元素，为操作方便，树的每个结点中含有一个指向双亲的指针，并约定用根结点代表这个集合。

### 并查集抽象数据类型定义

==暂时还没探索到==   ^ w ^ ~

### 并查集基本操作

==暂时还没探索到==   ^ w ^ ~

### 等价类划分

==暂时还没探索到==   ^ w ^ ~

## 6.7总结与提高

## 主要知识点

### 理解定义

本章介绍的一般树与二叉树均为树结构，树结构是最重要的非线性结构。

树结构与线性结构的差别:
在线性结构中前驱与后继结点均是唯一的,而树结构中有唯一前驱（除根结点)，有m个后继(m≥0)，其中二叉树是后继个数最多为2的树。

### 存储结构

- 二叉树采用二叉链表表示法实现存储
- 一般树,结点后继个数变化范围较大常采用树的二叉链表表示法实现存储（即孩子兄弟法)
- 树与二叉树之间是通过树与二叉树各自的二叉链表存储方法实现转换，只不过是解释不同

### 二叉树遍历算法

其一,通过遍历得到了二叉树中结点访问的线性序列，实现了非线性结构的线性化。

其二，遍历运算中的递归实现是程序设计中重要技术,理解递归含义、使用递归控制条件都非常重要。

### 递归到非递归的转换

- 递归执行时需要系统提供隐式栈实现递归,效率较低
- 适应无应用递归语句的语言设施环境条件
- 由于递归算法是一次执行完,这在处理有些问题时不适合

### 遍历应用

- 访问操作可以包罗对结点的所有操作,并不是只有打印等操作（如线索化题例)
- 分析应用问题对遍历顺序的要求(如树状打印题例)。

### 哈夫曼树

掌握哈夫曼树的概念，应用哈夫曼树构造哈夫曼编码,为应用解决数据压缩问题提供方法。





## 典型题例

### 二叉树相似性判断

设计算法,判断两棵二叉树是否相似。

所谓二叉树t1与2相似,是指t1和2都是空的二叉树;或者t1的左子树与t2的左子树相似，同时t1的右子树与t2的右子树相似。
依题意，本题的递归函数如下:

f(t1, t2)=TRUE          														若t1=t2=NULL
f(t1, t2)=FALSE         														若t1与2之一为NULL
f(t1, t2)= f(t1->left, t2->left)&& f(t1->right, t2->right)         若t1与2均不为NULL

算法描述

```c
int llike (BiTree b1,BiTree b2)
/*判断二叉树b1和b2是否相似，若相似,返回1，否则返回0*/
{
    int like1,like2;
    if (b1==NULL && b2==NULL)
    	return(1);/*b1和b2均为空树，相似，返回1*/
    else if (b1==NULL ll b2==NULL)
    	return(O);/*b1和b2其中之一为空树,不相似,返回0*/
    else
        {
            like1=like (t1->left, t2->left);
            /*判断b1和b2的左子树是否相似*/
            like2=like (t1->right, t2->right);/*判断b1和b2的右子树是否相似*/
            return (like1 && like2);
        }
}
```



### 求从二叉树根结点到r结点之间的路径3

二叉树采用二叉链表方式存储,root指向根结点,r所指结点为任二名光内记尔o出从根结点到结点r之间的路径。

【问题分析】

①后序遍历访问到r所指结点时，栈中结点均为r所指结点的祖先,这些祖先结点便构成了一条从根结点到r所指结点的路径，故应采用后序遍历方法。
②递归的栈区是由系统隐式控制,为了能在找到结点r时控制输出，需把系统栈变成为用户自己控制的栈,故应使用非递归的后序遍历算法。



【算法描述】

```c
void path (BiTree root, BITNode *r)
{
    BiTree s[Stack_Size];
    p = root;
    q= NULL;/*用q保存刚遍历过的结点,初始为空*/
    while (p != NULL || top != 0)
    {
        while (p != NULL)
            { 
                 top ++;
                if(top>=Stack_Size)
                    OverFlow();
                 s[top]= p;p=p-> LChild;
            }
          		 /* 遍历左子树*/
            if ( top > 0 )
            { 
                p=s[top];/*根结点*/
                if (p-> RChild == NULL ll p->RChild = q )
                    {
                        if (p= =r)/*找到r所指结点，则显示从根结点到r所指结点之间的路径*/
                            {
                                for(i=1;i<=top;i++)
                                    printf("%d ",s[i]->data);top=0; 
                            }
                                q=p;
                                top--;
                                p = NULL;/*跳过前面左遍历，继续退栈*/
                    }
                        else p =p->RChild;/*遍历右子树*/}
            }
    }
}
```





### 层次遍历二叉树

层次遍历是指从二叉树的第一层(根结点)开始逐层遍历,同一层中,按照从左到右对结点访问。直到二叉树中所有结点均被访问且仅访问一次。

实现层次遍历，需采用队列技术。
设置一个队列Q,暂存某层已访问过的结点,同时也保存了该层结点访问的先后次序。按照该层结点访问的次序实现对其下层孩子结点的按次序访问。

【算法思想】

1. 初始化空队列Q;
2. 若二叉树bt为空树，则直接返回;
3. 将二叉树的根结点指针bt放人队列Q;
4. 若队列非空，则重复如下操作:
   1. 队头元素出队并访问该元素;
   2. 若该结点的左孩子非空，则将该结点的左孩子结点指针入队;
   3. 若该结点的右孩子非空，则将该结点的右孩子结点指针人队;



【算法描述】

```c
int LayerOrder(BiTree bt) SeqQueue * Q;
{
    BiTree p;
    InitQueue (Q) ;
    if(bt= =NULL)
    	return ERROR;
    EnterQueue(Q, bt);
    while (!lsEmpty(Q))
    {
        DeleteQueue(Q, &p);
        visit(p->data);
    	if(p-> LChild )
    		EnterQueue(a,p-> LChild) ;
    	if(p-> RChild )
    		EnterQueue(Q, p-> RChild) ;
    }
    return OK;
}
```





---

# 第7章 图

## 7.1图的定义与基本术语

### 7.1.1图的定义

图(Graph)是一种网状数据结构,其形式化定义如下:

```
Graph= (V，R)
V={ x | x ∈ DataObject }
R={ VR }
VR={ <x,y> | P(x,y) ∩ (x,y∈v) }
```


DataObject为一个集合,该集合中的所有元素具有相同的特性。

V中的数据元素通常称为顶点( vertex )
VR是两个顶点之间的关系的集合。
P (x,y)表示×和y之间有特定的关联属性。

若<x, y>EVR，则<x,y>表示从顶点x到顶点y的弧（arc)，称x为弧尾(tail)或起始点,称y为弧头(head）或终端点。此时图中的边是有方向的，称为有向图。
若<x，y>EVR，必有<y，x>EVR,即VR是对称关系，这时以无序对(x，y）来代替两个有序对,表示x和y之间的一条边（edge），这样的图称为无向图。

在图中，我们可以将任一顶点看成是图的第一个顶点，即对于任一顶点，它的邻接点之间不存在顺序关系。为了操作的方便,我们将图中的顶点按任意序列排列起来。顶点在这个人为的随意排列中的位置序号称为顶点在图中的位置。

图的基本操作和其它数据结构一样，也有创建、插入、删除、查找等操作。

基本操作:

1. GreateGraph(G):创建图G。
2. DestoryGraph(G):销毁图G。
3. LocateVertex (G, v):确定顶点v在图G中的位置。若图G中没有顶点v，则函数值为“空”。
4. GetVertex(G,I):取出图G中的第i个顶点的值。若i>图G中顶点数，则函数值为“空”。
5. FirstAdjVertex(G,v):求图G中顶点v的第一个邻接点。若v无邻接点或图G中无顶点v，则函数值为“空”
6. NextAdjVertex (G,v,w):已知w是图G中顶点v的某个邻接点，求顶点v的下一个邻接点（紧跟在w后面）。若w是v的最后一个邻接点,则函数值为“空”
7. InsertVertex (G, u):在图G中增加1个顶点u。
8. DeleteVertex (G，v):删除图G的顶点v及与顶点v相关联的弧。
9. InsertArc (G,v,w):在图G中增加一条从顶点v到顶点w的弧。
10. DeleteArc (G, v,w） :删除图G中从顶点v到顶点w的弧。
11. TraverseGraph (G):按照某种次序，对图G的每个结点访问一次且最多一次。

### 7.1.2基本术语

#### 图

##### 无向图

无向图:若<x，y>EVR，必有<y，x>∈VR，即VR是对称关系，这时以无序对（x，y）来代替两个有序,表示x和y之间的一条边(edge），此时的图称为无向图。

![](https://p.ananas.chaoxing.com/star3/origin/bb5dd81e7f6b0c866f6986b60a05eed2.png?rw=549&rh=451&_fileSize=27886&_orientation=1)

##### 有向图

有向图:若图中的边是有方向的，称这样的图为有向图。

![](https://p.ananas.chaoxing.com/star3/origin/5b7179e6dd279b46cf26c593d42f1966.png?rw=554&rh=493&_fileSize=30693&_orientation=1)

##### 完全图

有向完全图:有n (n-1 )条边（图中每个顶点和其余n-1个顶点都有弧相连)的有向图为有向完全图。

无向完全图:有n (n-1 )/ 2条边（图中每个顶点和其余n -1个顶点都有边相连）的无向图为无向完全图。
注:对于有很少条边的图(e < nlog n）称为稀疏图,反之称为稠密图。

##### 子图

子图:设有两个图G=(V，{E}）和图G' = (v',{E'}），若V'含于V且E含于E,则称图G'为G的子图

以下为 G1  的 子图：

![](https://p.ananas.chaoxing.com/star3/origin/c403625b3dc35a66d68549532525092e.png?rw=675&rh=839&_fileSize=57653&_orientation=1)

##### 连通图

###### 连通图

连通图:在无向图G=(V，{E})中，若从vi到vj有路径相通，则称顶点vi与vj是连通的。如果对于图中的任意两个顶点vi、 vj∈v,vi, vj都是连通的，则称该无向图G为连通图。

![](https://p.ananas.chaoxing.com/star3/origin/0ea9624333762effd9cbba719add31a2.png?rw=479&rh=430&_fileSize=26261&_orientation=1)

###### 连通分重

连通分量:无向图中的极大连通子图称为该无向图的连通分量。

![img](https://p.ananas.chaoxing.com/star3/origin/f46daadd5f48c77522d8ffc473c329ac.png?rw=552&rh=553&_fileSize=46134&_orientation=1)

![](https://p.ananas.chaoxing.com/star3/origin/57979e0bc90be4d20add9a2ad5f0a4bc.png?rw=634&rh=824&_fileSize=60872&_orientation=1)

###### 强连通图

强连通图:在有向图G=(v,{A})中，若对于每对顶点vi、 vj∈V且vi≠vj，从vi到vj和vj到vi都有路径，则称该有向图为强连通图。

![](https://p.ananas.chaoxing.com/star3/origin/64741480510c28b309e2bfbd33c4c572.png?rw=608&rh=443&_fileSize=40363&_orientation=1)

###### 强连通分量

强连通分量:有向图的极大强连通子图称作有向图的强连通分量。

G1 的强连通分量

![](https://p.ananas.chaoxing.com/star3/origin/2b955041aa9de506c94b416e3acc8e1c.png?rw=507&rh=663&_fileSize=38993&_orientation=1)

#### 邻接点

对于无向图G=(V，{E}) ,如果边（v，v')∈E，则称顶点v, v互为邻接点，即v，v’相邻接。边（v，v')依附于顶点v和v'，或者说边(v，v）与顶点v和v’相关联。对于有向图G=(V，{A}）而言，若弧<v，v'∈A，则称顶点v邻接到顶点v',顶点v’邻接自顶点v，或者说弧<v,v'>与顶点v，v'相关联。

#### 路径和回路

##### 路径

无向图路径无向图G=(v,{E}）中从顶点v到v的路径是一个顶点序列vi0，Vi1,Vi2,, Vin,其中(Vi j-1,vij) ∈E，1≤j≤n。

有向图路径

如果图G是有向图，则路径也是有向的，顶点序列应满足<Vij-1,Vij>∈A,1≤j≤n。



##### 路径长度

路径长度:指路径上经过的弧或边的数目。

##### 回路或环

回路或环:在一个路径中，若其第一个顶点和最后一个顶点是相同的，即v=v',称该路径为一个回路或环。

##### 简单路径

简单路径:若表示路径的顶点序列中的顶点各不相同,则称这样的路径为简单路径。

##### 简单回路

简单回路:除了第一个和最后一个顶点外，其余各顶点均不重复出现的回路为简单回路。

#### 度

##### 度

无向图:顶点v的度是指和v相联的边的数目，记作
TD (v)

有向图:对有向图而言顶点v的度有出度和入度两部分:以顶点v为弧头的弧的数目称为该顶点的入度,记作ID(v），以顶点v为弧尾的弧的数目称为该顶点的出度,记作OD(v）则顶点v的度为:
TD (v) = lD (v) + OD (v)

##### 度的计算公式

一般地，若图G中有n个顶点,e条边或弧，则图中顶点的度与边的关系如下:
$$
e=\frac{\sum_{i=1}TD(V_i)}{2}
$$


#### 权与网

在实际应用中，有时图的边或弧上往往与具有一定意义的数有关，即每一条边都有与它相关的数,称为权，这些权可以表示从一个顶点到另一个顶点的距离或耗费等信息。我们将这种带权的图叫做赋权图或网。

![](https://p.ananas.chaoxing.com/star3/origin/d08908873cbeaabd039266b5452e82e9.png?rw=608&rh=397&_fileSize=43806&_orientation=1)

#### 生成树

一个连通图的生成树是指一个极小连通子图，它含有图中的全部顶点，但只有足已构成一棵树的n-1条边。

![](https://p.ananas.chaoxing.com/star3/origin/5b7aea29056707afabaf5d17c5774e4c.png?rw=1311&rh=721&_fileSize=131869&_orientation=1)

## 7.2图的存储结构

### 邻接矩阵表示法

#### 定义

采用两个数组来表示图:一个是用于存储顶点信息的一维数组;另一个是用于存储图中顶点之间关联关系的二维数组，这个关联关系数组被称为邻接矩阵。

#### 表示

G是一具有n个顶点的无权图，G的邻接矩阵是如下性质的n×n矩阵A:
$$
A[i,j]=\left\{\begin{matrix}1，&(v_i,v_j)\in VR\\0，&(v_i,v_j)\in VR\leq0 \end{matrix}\right.
$$
![](https://p.ananas.chaoxing.com/star3/origin/fba74e90096761dfc265d50cbf1aafc4.png?rw=813&rh=753&_fileSize=91521&_orientation=1)

若图G是一个有n个顶点的网,则它的邻接矩阵是具有如下性质的n×n矩阵A :
$$
A[i,j]=\left\{\begin{matrix}W_{ij}，&(v_i,v_j)\in VR\\\infty，&(v_i,v_j)\in VR\leq0 \end{matrix}\right.
$$
![](https://p.ananas.chaoxing.com/star3/origin/0aa1f2508efbd95f8c9f14c1e48d210f.png?rw=1479&rh=577&_fileSize=211693&_orientation=1)

#### C语言类型描述

```c
#define MAX_VERTEX_NUM 20
#define INFINITY 32768
typedefenum {
    DG,DN,UDG,UDN} GraphKind;
typedef char
VertexData;
typedefstruct ArcNode {
	AdjType adj ;
	otherInfo info;
}ArcNode;
```

```c
typedefstruct 
{
    VertexData vexs [MAX_VERTEX_NUM];
    ArcNode arcs [MAX_VERTEX_NUM]
    [MAX_VERTEX_NUM] ;
    int vexnum,arcnum;
    GraphKind kind ;
}AdjMatrix;
```



#### 特点

##### 存储空间

无向图
邻接矩阵是对称矩阵,所以可采用压缩存储法(下三角），其存储空间只需n (n-1)/2。
有向图
邻接矩阵不一定是对称矩阵,所以需要n2个存储空间。

##### 便于运算

1)便于判定图中任意两个顶点之间是否有边相连，即根据A[i，j]=0或1来判断。
2)便于求得各个顶点的度。

无向图:其邻接矩阵第i行元素之和就是图中第i个顶点的度:
$$
TD(v_i)=\sum^n_{j=1}A[i,j]
$$
有向图:第i行元素之和就是图中第i个顶点的出度
第i列元素之和就是图中第i个顶点的入度
出度
$$
OD(v_i)=\sum^n_{j=1}A[i,j]
$$
入度
$$
ID(v_i)=\sum^n_{j=1}A[i,j]
$$


##### 便于实现一些基本操作

如FirstAd jVertex (G，v) :

1. 首先，LocateVertex (G,v)找到v在图中的位置，即v在一维数组vexs中的序号i。

2. 二维数组arcs中第i行上第一个adj域非零的分量所在的列号j，便是v的第一个邻接点在图G中的位置。

3. 取出一维数组vexs[j]中的数据信息,即与顶点v邻接的第一个邻接点的信息

   

#### 创建有向网的算法

```c
int CreateDN (AdjMatrix *G)
{ 
    int i, j, k, weight;
    VertexData v1, v2;
    scanf ("%d,%d ", &G->arcnum, &G->vexnum);
        for (i=O ; i<G->vexnum; i++)
    		for(j=O; j<G->vexnum; j++)
   				G->arcs[i][j].adj=lNFINITY;
    	for (i=O; i<G->vexnum; i++)
    		scanf("%c",&G->vexs[i]);
    for(k=O;k<G->arcnum ; k++)
        {
            scanf ("%c，%c，%d",&v1,&v2,&weight);
            i=LocateVex_M(G,v1);
            j=LocateVex_M(G, v2);
            G->arcs[i][j].adj=weight;
        }
    return (Ok);
}
```

```c
int LocateVertex (AdjMatrix * G, VertexData v)
{
    int j=Error, k;
	for(k=0; k<G->vexnum; k++)
        	if(G->vexs[k]==v)
				{
                	j=k;
                	break;
            	}
    return(j) ;
}
```



### 邻接表表示法

#### 基本思想

它实际上是图的一种链式存储结构。具基本心心是只存有关联的信息，对于图中存在的边信息则存储,而对于不相邻接的顶点则不保留信息。在邻接表中,对图中的每个顶点建立一个带头结点的边链表，每个边链表的头结点又构成一个表头结点表。

#### 结构构成

一个n个顶点的图的邻接表表示由表头结点表与边表两部分构成。

表头结点表
由所有表头结点以顺序结构的形式存储，以便可以随机访问任一顶点的邻接点单链表。表头结点由两部分构成:

- 数据域（vexdata）
- 链域(firstarc）

边表

由表示图中顶点间邻接关系的n个边链表组成。它由三部分组成:

- 邻接点域（adjvex）
- 链域（(nextarc) 
- 数据域（info) 



#### 图例

![img](https://p.ananas.chaoxing.com/star3/origin/e58d82c8a8a7fe338504f761a2d7a6aa.png?rw=1048&rh=372&_fileSize=57340&_orientation=1)

![](https://p.ananas.chaoxing.com/star3/origin/10d09b473985b0fcc2bb3a2e02a0954c.png?rw=1180&rh=371&_fileSize=80569&_orientation=1)

#### 形式化说明

```c
#define MAX_VERTEX_NUM 10
typedefenum {DG,DN, UDG, UDN}
GraphKind;
typedefstruct ArcNode
{
int adjvex;
struct ArcNode *nextarc;
Otherlnfo info;
} ArcNode;

typedefstruct VertexNode 
{
    VertexData data;
	ArcNode *firstarc;
} VertexNode;
typedefstruct 
{
	VertexNode vertex[MAX_VERTEX_NUM];
    int vexnum, arcnum;
	GraphKind kind;
}AdjList;
```



#### 存储空间

对于有n个顶点，e条边的无向图而言:若采取邻接表作为存储结构，则需要n个表头结点和2e个表结点。

#### 无向图的度

在无向图的邻接表中，顶点vi的度恰好就是第i个边链表上结点的个数。

#### 有向图的度

在有向图中，第i个边链表上顶点的个数是顶点vi的出度。安他求得该顶点的入度,则必须遍历整个邻接表。在所有单链表中查找邻接点域的值为i的结点并计数求和。
由此可见，对于用邻接表方式存储的有向图，求顶点的入度并不方便，它需要扫描整个邻接表才能得到结果。

解决方法：

逆邻接表法
对每一顶点vi再建立一个逆邻接表，即对每个顶点vi建立一个所有以顶点vi为弧头的弧的表。这样求顶点vi的入度即是计算逆邻接表中第i个顶点的边链表中节点个数。

![](https://p.ananas.chaoxing.com/star3/origin/4d07c1bb4dcead3ebec67432810f1762.png?rw=1078&rh=418&_fileSize=52146&_orientation=1)

### 十字链表

#### 定义

十字链表(0rthogonal List）是有向图的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。
有向图中的每一条弧对应十字链表中的一个弧结点,同时有向图中的每个顶点在十字链表中对应有一个结点,叫做顶点结点。

#### 形式化定义

```c
#define MAX_VERTEX_NUM 20
typedef enum {DG,DN, UDG, UDN}
GraphKind;
typedefstruct ArcNode 
{
    int +tailvex，headvex;
    struct ArcNode *hlink，*tlink ;
}ArcNode;

typedef struct VertexNode 
{
    VertexData data;
    ArcNode *firstin，*firstout;
} VertexNode;

typedef struct
{
    Vertex
    Nodevertex[MAX_VERTEX_NUM];
    intvexnum,arcnum ;
    GraphKind
    kind ;
}OrthList;
```



#### 图例

![](https://p.ananas.chaoxing.com/star3/origin/e6bc9f9f698c5ee06c9575efaf15dd02.png?rw=885&rh=868&_fileSize=84688&_orientation=1)

#### 建立算法

```c
voidCrtOrthList (OrthList g)
{
    scanf ("%d,%d",&n,&e) ;
	for (i=0; i<n; i++)
		{
        	scanf (“%c”,g. vertex[i].data;g. vertexLi.firstin=NULL);
             g. vertexli.firsout=NULL;
         }
    for (k=O;k<e; k++)
    {
        scanf(“%c,%c”,&vt,&vh) ;
        i=LocateVertex (g,vt) ;
        j = LocateVertex （g,vh） ;
        p=al loc (sizeof (ArcNode));
        p->tailvex=i ; p->headvex=j ;
        p->tlink_= g. vertexLi].firstou ;
        g. vertexLi].firstout =p;
        p->hlink_= g. vertex Lj ].firstin;g. vertexLj].firstin =p;
    }
}
```



#### 优点

在十字链表中既能够很容易地找到以vi为尾的弧，也能够容易地找到以vi为头的弧,因此对于有向图,若采用十字链表作为存储结构，则很容易求出顶点vi的度



### 邻接多重表

#### 定义

邻接多重表(Ad jacencyMu l ti_list）是无向图的另外一种存储结构,之所以提出邻接多重表这种存储结构是因为它能够提供更为方便的边处理信息

邻接多重表是指将图中关于一条边的信息用一个结点来表示

#### 图例

![](https://p.ananas.chaoxing.com/star3/origin/c8c67736a8a8c67067475a4f0b5c48bf.png?rw=856&rh=844&_fileSize=96008&_orientation=1)

#### 结构类型说明

```c
typedef
struct EdgeNode {
int mark,ivex,jvex;
struct EdgeNode *ilink，*jlink;
}EdgeNode;

typedef struct {
VertexData data;
EdgeNode *firstedge;
} VertexNode;

typedef struct {
VertexNode vertex [MAX_VERTEX_NUM];
int vexnum,arcnum;
GraphKind kind;
}AdjMultiList;
```



## 7.3图的遍历

定义:从图中的某个顶点出发,按某种方法对图中的所有顶点访问且仅访问一次
访问标志用数组visited [ ] 

(1)保证图中的各顶点均被访问到。
(2)避免重复访问。



图的遍历方法

1. 访问初始顶点。
2. 按照某种策略依次对此连通子图中未被访问的顶点进行访问。
3. 寻找下一个未被访问顶点,转步骤（1）。
4. 重复上述步骤直至所有顶点均被访问。

```c
voidTraverseGraph (Graph g)
{
    for (vi=0; vi<g. vexnum; vi++)
    	visited[vi]=False:
    for( vi=0; vi<g. vexnum; vi++)
    	if ( ! visited[vi] )
    		Search(g, vi) ;
}
```

深度优先搜索

深度优先搜索DFS(Depth_First Search)是指按照深度方向搜索,它类似于树的先根遍历。

基本思想

1. 深度优先算法的基本思想是:从图中某个顶点v0出发,首先访问v0。

2. 找出刚访问过的顶点vi的第一个未被访问的邻接点,然后访问该顶点。重复此步骤,直到当前的顶点没有未被访问的邻接点为止。

3. 返回前一个访问过的顶点，找出该顶点的下一个未被访问的邻接点,访问该顶点。转(2)。

   

递归形式的基本思想

采用递归的形式说明，则深度优先搜索连通子图的的基本思想可表示为:

1. 访问出发点v0。
2. 依次以v0的未被访问的邻接点为出发点，深度优先搜索图，直至图中所有与v0有路径相通的顶点都被访问。

若此时图中还有顶点未被访问，则另选图中一个未被访问的顶点作为起始点， 重复上述搜索过程，直至所有顶点均被访问过为止。



递归算法

```c
void TraverseGraph (Graph g)/*对图g进行深度优先搜索，Graph表示图的一种存储结构，如数组表示法或邻接表等*/
{
	for (vi=0;vi<g.vexnum;vi+t)
        	visited[vi]=False/*访问标志数组初始*/
	for ( vi=0 ;vi<g.vexnum; vi++)/*调用深度遍历连通子图的操作*/
			/*若图g是连通图，则此循环只执行一次*/
		if (! visited[vi])
            DepthFirstSearch(g,vi);
}/*TraverseGraph */

void DepthFirstSearch (Graph g, int vO)/*深度遍历vO所在的连通子图*/
{
	visit (v0);
    visited[v0] =True;
/*访问顶点v0，并置访问标志数组相应分量值*/
    w=FirstAdjVertex(g,vO);
	while ( w!=-1)/*邻接点存在*/
	{
        if(! visited [w] )
            DepthFirstSearch(g,w);/*递归调用DepthFirstSearch*/
		w=NextAdjVertex(g,v0,w);/*找下一个邻接点*/
    }
}/*DepthFirstSearch*/
```

邻接矩阵实现DFS

```c
void DepthFirstSearch (AdjMatrix g,int vO)/*图g 为邻接矩阵类型AdjMatrix */
{
	visit(vO) ;visited[v0]=True;
    for ( vj=0;vj<n; vj++)
	if (!visited[vj] &&g.arcs[vo] [vj].adj==1)
        DepthFirstSearch(g, v j);
}/*DepthFirstSearch*/
```

邻接表实现DFS

```c
voidDepthFirstSearch(AdjList g,int vO)
{
    visit(v0);
visited [v0]=True;
p=g.vertex[v0].firstarc;
    while( p!=NULL )
		{
        	if(! visited [p->adjvex])
			DepthFirstSearch (g，p->adjvex) ;
        p=p->nextarc;
}
}
```



非递归算法

(1）首先将v0入栈;
(2）只要栈不空，则重复下述处理:

栈顶顶点出栈,如果未访问,
则访问并置访问标志;
然后将该顶点所有未访问的邻接点入栈。

```c
void DepthFirstSearch (Graph g.int vO)
{
    lnitStack (S);
	Push(S,vO) ;
	while ( ! Empty (S))
    {
        v=Pop(S);
		if (!visited[v])
			{
                visit(v);
                visited[v]=True;
                w= FirstAdjVertex (g, v);
                while (w !=-1 )
                    {
                        if (!visited [w])
                            Push(S, w);
                    	w=NextAdjVertex (g, v, w);
            		}
			}
    }
}
```



广度优先搜索

广度优先搜索BFS
(Breadth_First Search)是指按照广度方向搜索.它类似于树的按层次遍历。

基本思想

1. 从图中某个顶点vO出发，首先访问v0。
2. 依次访问v0的各个未被访问的邻接点。
3. 分别从这些邻接点（端结点)出发,依次访问它们的各个未被访问的邻接点(新的端结点）。

访问时应保证:如果Vi和V为当前端结点,且Vi在V么k之前被访问，则Vi的所有未被访问的邻接点应在Vk的所有未被访问的邻接点之前访问。重复(3），直到所有端结点均没有未被访问的邻接点为止。

```C
void BreadthFirstSearch (Graph g,int vO)/*广度优先搜索图g中v0所在的连通子图*/
{
    visit(v0); visited[v0]=True;lnitQueue(&Q);/*初始化空队*/
        EnterQueue (&Q, vO);/*v0进队*/
        while ( ! Empty(Q))
            {
                DeleteQueue(&Q,&v);/*队头元素出队*/
                w=FirstAdj(g, v);/*求v的第一个邻接点*/
                while (w !=-1 )
                    {
                        if (!visited (w))
                            {
                                visit(w); visited[w]=True;
                                EnterQueue (&Q,w) ;
                            }
                        w=NextAdj (g, v, w);/*求v相对于w的下一个邻接点*/]
                    }
            }
}
```

## 7.4图的应用

### 7.4.1图的连通性问题

#### 无向图的连通分量

连通图仅需要调用一次搜索过程,即从任一个顶点出发，便可以遍历图中的各个顶点。
非连通图需要多次调用搜索过程，而每次调用得到的顶点访问序列恰为各连通分量中的顶点集。调用搜索过程的次数就是该图连通分量的个数。

#### 两顶点之间的简单路径

在图的应用问题中，常常需要找从顶点u到另一个顶点v的简单路径，即路径中的顶点均不相同。u到v可能存在多条简单路径，由于遍历过程将走遍图中的所有顶点，故可以在深度（或广度）优先搜索算法基础上加以适当的条件，就能得到求解此问题的算法，因此可以将此问题看成是有条件的图遍历过程。

【算法思想】

从顶点u开始，进行深度(或广度）优先搜索，如能够搜索到顶点v，则表明从顶点u到顶点v有一条路径。由于在搜索过祥丛世一发省虽在搜索过程以这条路径必定是一条简单路径。只要在搜索过程中，把搜索的线路记录下来，并在搜索到顶点vj时退出搜索，就可得到从u到v的一条简单路径。

为了记录搜索线路，需要设置一个数组pre [n],当从某个顶vi找到其邻接顶点vj进行访问时，将pre[j]置为i。这样，当退出搜索后,就能根据pre数组从顶点v追溯到顶点u。在具体设计算法时，可用pre数组替代visited数组，用pre[j]=-1表示vj未被访问。

【算法描述】

```c
int *pre;
void one_path(Graph *G, int u,int v)
{
    int i ;
    pre= (int *)malloc (G->vexnum*sizeof(int));
    for(i=O;i<G->vexnum; i++)
        pre[i]=一1;
	pre[u]=u;
	DFS_path(G, u,v);free (pre) ;
}
```

```c
Void DFS_path(Graph*G,int u,int v)
{
    int j;
	if(pre[v] !=-1)
	for(j=firstad j (G,u); j>=O; j=nextadj (G, u, j))
		if (pre[j]==一1)
            {
                pre[j]=u
                if (j==v)
                    print_path(pre ,v)
                else 
                    DFS_path(G,j,v);
        	}
}
```



#### 生成树

连通图的一个极小连通子图，含全部n个顶点，和n-1条边。如果在生成树上加一条边,必定构成一个环。即，一棵有n个顶点的生成树必有且仅有n-1条边。
有n-1条边的图并非一定连通,不一定存在生成树。如果一个图有n个顶点且边数小于n-1条，则该图一定是非连通图。

#### 最小生成树

【最小生成树】
在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该连通网的最小代价生成树。

最小生成树的重要性质如下:

设N=(V,{E}）是一连通网,U是顶点集V的一个非空子集。若(u , v)是一条具有最小权值的边，其u∈u,v∈V-U，则存在一棵包含边(u , v）的最小生成树。

【反证法证明】

假设不存在这样一棵包含边（u ,v)的最小生成树。任取一棵最小生成树T，将(u , v)加入T中。根据树的性质，此时T中必形成一个包含(u , v）的回路，且回路中必有一条边(u’, v’）的权值大于或等于(u , v)）的权值。删除（u ,v)，则得到一棵代价小于等于T的生成树T’，且T’为一棵包含边(u ,v)的最小生成树。这与假设矛盾。



##### 普里姆算法

算法思想:
假设N=(V,{E})是连通网，TE为最小生成树中边的集合。

1. 初始U={u0} (u0∈V),TE=是Ф ;
2. 在所有u∈U, v∈V-U的边中选一条代价最小的边(u0，v0）并入集合TE，同时将v0并入U;
3. 重复(2），直到U=V为止。此时，TE中必含有n-1条边，则T= (v,{TE})为N的最小生成树。

##### 克鲁斯卡尔算法

假设N=(V，{E})是连通网，将N中的边按权值从小到大的顺序排列;

1. 将n个顶点看成n个集合;
2. 按权值由小到大的顺序选择边，所选边应满足两个顶点不在同一个顶点集合内，将该边放到生成树边的集合中。同时将该边的两个顶点所在的顶点集合合并;
3. 重复(2），直到所有的顶点都在同一个顶点集合内。

### 7.4.2 有向无环图的应用

#### 拓扑排序（Topological Sort）

##### AOV一网

用顶点表示活动，用弧表示活动间的优先关系的有向无环图,称为顶点表示活动的网，简称为AOV一网。

![](https://p.ananas.chaoxing.com/star3/origin/7d2c91b594d7695329ea31e5526cefc5.png?rw=1286&rh=714&_fileSize=175490&_orientation=1)

##### 拓扑序列

在有向图G=(V，{E})中，V中顶点的线性序列称为拓扑序列。
此序列必须满足:对序列中任意两个顶点vi、 vj,在G中有一条从vi到vj的路径，则在序列中vi必排在vj之前。

##### 拓扑网的特性

拓扑网的特性如下:

(1)先行关系具有可传递性。

(2)拓扑序列不是唯一的。

![](https://p.ananas.chaoxing.com/star3/origin/5445ece03b0cb565b231c1ae9c3c2521.png?rw=793&rh=534&_fileSize=89611&_orientation=1)

##### 拓扑排序的基本思想

求拓扑排序的基本思想:

1. 从有向图中选一个无前驱的顶点输出;
2. 将此顶点和以它为起点的弧删除;
3. 重复(1)、(2)，直到不存在无前驱的顶点;
4. 若此时输出顶点数小于有向图中的顶点数,则说明有向图中存在回路，否则输出的顶点的顺序即为一个拓扑序列。

##### 拓扑排序算法

对于有向图的不同存储形式,有不同实现的拓扑排序算法。
1）基于邻接矩阵

![](https://p.ananas.chaoxing.com/star3/origin/32fcc59bbd9f317673d9ab0ac512a89e.png?rw=1361&rh=892&_fileSize=334990&_orientation=1)

2）基于邻接表

![](https://p.ananas.chaoxing.com/star3/origin/cbe715b8e704e8c89b64a53e15c27253.png?rw=1317&rh=843&_fileSize=247719&_orientation=1)

```C
int TopoSort (AdjList G)
{
    Stack S;
    int indegree[MAX_VERTEX_NUM];
    int i,count,k;
    ArcNode *p ;
    FindID(G, indegree);
    /*求各顶点入度*/
    lnitStack (&S);
    for (i=O; i<G. vexnum; i++)
        if(indegree[i]==O)Push(&S,i);
    /*将入度为0的顶点入栈*/
    		count=O;
    	while( ! StackEmpty (S))
            {
				Pop (&S,&i) ;
				printf("%c",G. vertex[i].data) ;
    			count++;
    /*输出i号顶点并计数*/
    			p=G. vertexes[i].firstarc;
            	while(p!=NULL)
    			{
                    k=p->adjvex;
                    indegree[k]—-;    /*i号顶点的每个邻接点的入度减1*/+
                    if (indegree[k]==O)Push(&S, k);/*若入度减为0，则入栈*/
    				p=p->nextarc;
    			}
    		}/*while*/
    	if (count<G. vexnum)
    		return (Error) ;
    /*该有向图含有回路*/
    else 
        return (Ok) ;
}
```



#### 关键路径

##### AOE一网

用顶点表示活动，用弧表示活动间的优先关系的有向无环图,称为顶点表示活动的网，简称为AOV一网。

##### 在AOE-网中的基本概念

源点:存在唯一的、入度为零的顶点,叫源点。
汇点:存在唯一的、出度为零的顶点,叫汇点。
关键路径∶从源点到汇点的最长路径的长度即为完成整个工程任务所需的时间，该路径叫做关键路径
关键活动:关键路径上的活动叫做关键活动。

![](https://p.ananas.chaoxing.com/star3/origin/09935ba785493e82f3d86245d45155c9.png?rw=662&rh=849&_fileSize=137253&_orientation=1)

##### 几个重要的定义

ve (i)

事件vi的最早发生时间ve (i) :从源点到顶点vi的最长路径的长度。

vl (i)

事件vi的最晚发生时间vl(i):在保证汇点按其最早发生时间发生这一前提下，事件vi的最晚发生时间

e ( i)

活动ai的最早开始时e(i) :如果活动ai对应的弧为<j , k>，则e (i)等于从源点到顶点j的最长路径的长度,即:e ( i ) =ve ( j)

l ( i)

活动ai的最晚开始时间I(i) :如果活动ai对应的弧为<j,k>,其持续时间为dut (<j , k>)则l ( i) =vl (k)- dut (<j，k>)

a i的松弛时间

活动ai的松弛时间（时间余量): ai的最晚开始时间与a i的最早开始时间之差:l (i)- e (i)。

##### 求关键路径的基本步骤

1. 对图中顶点进行拓扑排序，在排序过程中按拓扑序列求出每个事件的最早发生时间ve (i) ;
2. 按逆拓扑序列求每个事件的最晚发生时间vl(i) ;
3. 求出每个活动ai的最早开始时间e( i )和最晚发生时间l(i) ;
4. 找出e ( i)=l (i)的活动ai，即为关键活动。

##### 修改后的拓扑排序算法

```c
int ve[MAX_VERTEX_NUM];/*每个顶点的最早发生时间*/
int TopoOrder (AdjList G, Stack *T)
/*T为返回拓扑序列的栈，S为存放入度为0的顶点的栈*/
{
    int count,i，j,k;ArcNode *p;
    int indegree[MAX_VERTEX_NUM];
    Stack s;
    lnitStack(T);
    lnitStack(&S);
    FindlD(G,indegree);
    for(i=O ; i<G. vexnum; i++)
    	if(indegree[i]==O)Push(&S,i);
    		count=O;
    	for(i=O; i<G. vexnum; i++)
    		ve[i]=O;/*初始化*/
    	while ( ! StackEmpty (s))
    		{
            	Pop(&S,& j);
            	Push(T,j);
            	count++;/*拓扑序列点入T栈*/
            	p=G.vertex[j].firstarc;
    			while(p!=NULL)
    				{
                    	k=p->adjvex ;
     					if(—-indegree[k]==O)
                            	Push(&S,k);
    					if(ve[j]+p->weight>ve[k])/*事件最早时间计算*/
    							ve[k]=ve[j]+p->weight;
    					p=p->nextarc;
    				}/*while*/
        	}/*while*/
    		if(count<G. vexnum)
        		return (Error) ;
    else return(Ok);
}
```



##### 求关键路径的实现算法

```c
int CriticalPath (AdjList G)
{
    ArcNode*p;
    int i,j,k, dut,ei,l i ;
    char tag;
    intvl[MAX_VERTEX_NUM];
    Stack T;
    if(!TopoOrder (G,&T))
        return(Error) ;
    for (i=O; i<G. vexnum; i++)
    	vl[i]=ve[i];/*初始化*/
    while(!StackEmpty(T))
    	{
        	Pop(&T,& j);
    		p=G. vertex[j].firstarc;
        	while(p !=NULL)
    			{
                	k=p->adjvex;
                	dut=p->infor. weight;
                	if(vl[k]-dut<vl[j])
    					vl[j]= vl[k]-dut;
    				p=p->nextarc;
            	}
    	}
    for(j=O; j<G.vexnum; j++)/*求ei,li和关键活动*/
    {
        p=G.vertex[j].firstarc;
        while (p!=NULL)
    		{
				k=p->Adjvex;
    			dut=p->weight;
				ei=ve[j];
				li=vl[k]-dut;
				tag=(ei==li)?'*':'';
    			printf ( "%c，%c，%d，%d,%d,%c \n",G.vertex[j].data,G.vertex[k].data,dut,ei,li,tag);/*输出关键活动*/
            	p=p->nextarc;
    		} 
    }
    return(Ok);
}                         
```

![](https://p.ananas.chaoxing.com/star3/origin/49202c69a843d2de15e3579ff862074a.png?rw=764&rh=839&_fileSize=133896&_orientation=1)

### 7.4.3 最短路径

求某一顶点到其它各顶点的最短路径

迪杰斯特拉(Dijkstra）算法
基本思想

==建议B站搜索==

算法步骤

1. g为用邻接矩阵表示的带权图。s<—{v0} , dist[i]=g.arcs [v0] [vi]将v0到其余顶点的路径长度初始化为权值
2. 选择vk，使得dist[vk]=min(dist[i] l viEv一S)vk为目前求得的下一条从v0出发的最短路径的终点。
3. 修改从v0出发到集合V一S上任一顶点vi的最短路径的长度。如果dist[k]+g. arcs[k] [i]<dist[i]则将dist[i]修改为:dist [k]+ g. arcs[k] [i]
4. 重复(2)、(3) n-1次，即可按最短路径长度的递增顺序,逐个求出v0到图中其它每个顶点的最短路径。

算法描述

```c
ShortestPath_DJS(AdjMatrix g, int v0,
WeightType dist[MAX_VERTEX_NUM]，/*存放i的当前最短路径长度*/
VertexSet path[MAX_VERTEX_NUM])/*存放i的当前最短路径*/
{
    VertexSets;			/* s为已找到最短路径的终点集合*/
    for ( i =O ; i<g. vexnum ;i++)/*初始化dist[i]和path[i] */
    {
        lnitList(&path[i]);
        dist[i]=g.arcs[v0][i];
        if( dist[i]<MAX)
        {
            AddTail(&path[i], g.vexs[vo]) ;
            AddTail (&path[i], g.vexs[i]);
            lnitList(&s);
            AddTail (&s，g. vexs[v0]);
        }
    }
    for ( t = 1 ;t<=g.vexnum-1 ; t++)
		{
        	min=MAX;
			for(i =O; i<g. vexnum; i++)
				if(! Member(g.vex[i], s)&&dist[i]<min)
                        lk =i;
            min=dist[i];}
            AddTail(&s,g. vexs[k]);
            for ( i =0; i<g. vexnum; i++)
                if (!Member(g. vex[i],s)&&(dist[k]+g.arcs [k][i]<dist[i]))
                    {
                        dist[i]=dist[k]+ g.arcs [k][i];
                        path[i]=path[k];
                        AddTail(&path[i],g.vexs[i]);/* path[i]=path[k]U{Vi}*/
                    }
		}
}
```





求任意一对顶点间的最短路径

佛罗依德算法(Floyd)
基本思想

==建议B站搜索==

算法描述

```c
ShortestPath_Floyd (
	AdjMatrix g，
	WeightType dist [MAX] [MAX],VertexSet path[MAX] [MAX])
{
    for (i=O; i<g. vexnumn; i++)
        for (j =0; j<g.vexnum;j++)
        	{
				InitList(&path[i][j]);/*初始化dist[i][j]和path[i][j]*/
				dist[i][j]=g.arcs[i][j];
				if (dist[i][j]<MAX)
				{
                    AddTail(&path[i][j]，g. vexs[i]);
                    AddTail (&path[i][j],g. vexs[j]);
				}
			}
	for (k =O;k<g. vexnum; k++)
        for (i =O ; i<g. vexnum; i++)
            for (j=0; j<g. vexnum; j++)
				if (dist[i][k]+dist[k][j]<dist[i][j])
					{
						dist[i][j]=dist[i][k]+dist[k][j];
						paht[i][j]=JoinList (paht[i][k]， paht[k][j]);
					} 
}
```



## 7.5总结与提高

### 主要知识点

#### 基本概念

图中顶点间的关系可以任意的，因此图是最复杂的非线性结构，它的表达力强。
图具有有向图、无向图、连通图、强连通图、完全图、赋权图等多种类型。

#### 图的存储结构

图的存储方式一般有两类，用边的集合方式有邻接矩阵,链接方式有邻接表、十字链表、邻接多重表。
邻接矩阵和邻接表是两种常用的存储结构.适用于有向图（网）和无向图（网）表示与处理。

#### 图的基本操作

为实现遍历必须设置访问标志数组,以防止走回路或未访问到。
图的遍历规律有两种:深度优先遍历DFS和广度优先遍历BFS。可用邻接矩阵和邻接表实现。
深度优先遍历算法是以递归技术为支持，而广度优先遍历算法是以队列技术为支持的。

#### 图的应用

图的遍历算法是图应用的重要基础。

求解生成树、最小生成树、连通分量、拓扑排序、关键路径、单源最短路径及所有顶点之间的最短路径的重要算法应用。

### 典型题例

#### 求距离顶点vo的最短路径长度为k的所有顶点

已知无向图g，设计算法求距离顶点v0的最短路径长度为K的所有顶点,要求尽可能节省时间。

【问题分析】

从顶点v0开始进行广度优先搜索，将一步可达的、两步可达的…直至k步可达的所有顶点记:录下来，
同时用一个队列记录每个结点的层号，输出第K+1层的所有结点即为所求。

【算法描述】

```c
void bfsKLevel (Graphg,intv0,intK)
{
    InitQueue ( Q1);/*Q1是存放已访问顶点的队列*/
	InitQueue ( Q2);/*Q2是存放已访问顶点层号的队列*/
	for ( i=0; i < g . vexnum; i++)
		visited[i]=FALSE;/*初始化访问标志数组*/
	visited[v0]=TRUE; Level=1;
	EnterQueue ( Q1，vO);
	EnterQueue( Q2，Level) ;
	while (! lsEmpty ( Q1))
		{
			v=DeleteQueue ( Q1);/*取出已访问的顶点号*/
			Level=DeleteQueue ( Q2);/*取出已访问顶点的层号*/
			w=FirstAdjVertex(g, v) ;/*找第一个邻接点*/
			while ( w!=-1 )
				{
					if (! visited[w] )
					{
						if(Level==K)
							printf(“%d”, w);/*输出符合条件的结点*/
						else
							visited[w]=TRUE;
						EnterQueue( Q1，w);
                        	EnterQueue ( Q2,Level+1) ;
					}
					w=NextAdjVertex(g,v, w);
				}
		}/*找下一个邻接点*/
}
```



#### 设计算法在图g中找出一条包含所有顶点的简单路径

设计算法在图g中找出一条包含所有顶点的简单路径
【问题分析】

从任一顶点开始进行深度优先搜索，同时记录当前路径结点序列和当前路径结点数目。当递归进层时结点数目加1,退层时结点数目减1,
当结点数目等于结点总数时，输出当前路径结点序列，成功返回。

【算法描述】

```c
void Hamilton (Graph g)
{
	for ( i=O; i < g .vexnum; i++)
		visited[i]=FALSE;/*初始化访问标志数组*/
		n=O;/*初始化路径上的顶点数*/
	for ( i=0; i < g . vexnum; i++)
		if (DepthFirstSearch (g, i)==1)
            return;/*一旦找到一条简单路径则返回*/
}
```

```c
int visited[MAX_VERTEX_NUM];
int path[MAX_VERTEX_NUM];/*记录路径上的顶点序列*/
int n;/*记录路径上的顶点数*/
int DepthFirstSearch(Graph g , int vO)
{
	visited[v0]=TRUE;/*设置访问标志*/
	n=n+1;/*递归进层时，路径上顶点数加1*/
	path[n]=v0;/*保存路径上的顶点*/
	if (n==g .vexnum )
        {
            Display (path);/*找到一条包含所有顶点的简单路径*/
            return 1;/*成功返回*/
        }
    w=FirstAdjVertex (g, vO);/*找第一个邻接点*/
    while (w!=-1)
        {
            if(! visited[w] && DepthFirstSearch (g,w)==1
            return 1;
            w=NextAdjVertex (g，v0, w) ;/*找下一个邻接点*/
        }
	visited[v0]=FALSE;/*递归退层时，取消访问标志，以便重新遍历该顶点*/
	n=n-1;/*递归退层时，路径上顶点数减1*/
	return 0;/*从当前结点vO出发，无法找到解路径，失败返回*/
}
```



#### 求图的中心顶点

一公司在某地区有n个产品销售点,现根据业务需要打算在其中某个销售点上建立一中心仓库向其它销售点提供产品。运输线路不同，运输费用也不同。若每天需要向各销售点运输一次产品，那么将中心仓库建在哪个销售点上，才能使运输费用最低

【问题分析】

求图的中心顶点即在一个带权图G中，求出这样一个顶点v，使得v到其余顶点的最短路径长度之和最小。首先用弗罗伊德算法求出各个顶点之间的最短路径长度,然后再求出每个顶点到其余各顶点的最短路径长度之和，从中选取一个最短路径长度之和最小的顶点。

【算法描述】

```c
int CenterVex (AdjMatrix )
{
    int i, j，k;
    float min,len;
    float A[MAX][ MAX];/*A[i][j]存放i和 j之间的最短路径长度*/
    for (i=O; i<G.vexnum; i++)/*初始化A[i][j]*/
    {
        for (j=0; j<G.vexnum; j++)A[i][j]=G.arcs[i][j].adj;
            A[i][i]=0;/*i到i的路径长度为0*/
        for (k=O; i<G.vexnum; k++)/*求出每一对顶点之间的最短路径长度*/
            for (i=O; i<G.vexnum; i++)
                for (j=0; j<G.vexnum; j++)
                    if (A[i][k]+A[k][j]<A[i][j])
                        A[i][j]=A[i][k]+A[k][j];
        min=MAXLEN; k=O;
        for (i=O; i<G.vexnum; i++){/*选择最短路径长度之和最小的顶点vK*/
            len=0;
        for(j=O; j<G.vexnum;j++)
            len=len+A[i][j]
        if(len<min)
        {
            k=i ;
            min=len;
        }
    }
    return(k);
}
```

---

# 内容总结

## 逻辑结构

### 集合结构

结构中的数据元素之间除了同属于一个集合的关系外，无任何其它关系。

### 线性结构

结构中的数据元素之间存在着一对一的线性关系

#### 线性表

n个类型相同的数据元素的有限序列,数据元素之间是一对一关系。

#### 限定性线性表(栈和队列)

栈和队列:操作受限制的特殊线性表，其特殊性在于限制线性表插入和删除等运算的位置

栈：运算位置限制在表尾（栈顶)

队列：运算受限制在表头和表尾

#### 串

串:组成线性表的每个元素是一个单字符

#### 数组和广义表

数组:组成线性表的元素可以是带有结构性质的元素。
广义表:组成线性表的元素可以是单一元素，可以是表。

### 非线性结构



#### 树

层次关系,数据元素之间存在一对多的关系。

#### 图

网状结构,数据元素之间存在多对多的任意关系。

## 存储结构

### 顺序

### 链式

## 典型技术

### 指针操作技术

### 数组运算特征

### 树的遍历（递归、递归到非递归的转换)

### 图的遍历（深度、广度)



---

# 第八章查找

## 8.1查找的基本概念

### 列表

由同一类型的数据元素(或记录）构成的集合可利用任意数据结构实现。

### 关键字

数据元素的某个数据项的值，用它可以标识列表中的一个或一组数据元素。
如果一个关键字可以唯一标识列表中的一个数据元素，则称其为主关键字，否则为次关键字。当数据元素仅有一个数据项时，数据元素的值就是关键字。

### 查找

【定义】

根据给定的关键字值，在特定的列表中确定一个其关键字与给定值相同的数据元素，并返回该数据元素在列表中的位置。
若找到相应的数据元素,则称查找是成功的，否则称查找是失败的。

【查找的参数】

- ①查找对象K（找什么)
- ②查找范围L（在哪找)
- ③K在L中的位置（查找的结果)

其中①、②为输入参量,③为输出参量。在函数中，输入参量必不可少，输出参量也可用函数返回值表小。



### 平均查找长度

为确定数据元素在列表中的位置,需和给定值进行比较的关键字个数的期望值,称为查找算法在查找成功时的==平均查找长度==

对于长度为 n 的列表，查找成功时的平均查找长度为:
$$
ASL=P_1C_1+ P_2G_2+\cdots+ P_nC_n=\sum_{i-1}^nP_iC_i
$$

P~i~为查找第i个数据元素的概率C为找到列表中第i个数据元素时已经进行过的关键字比较次数

### 查找基本方法

比较式查找法

1. 基于线性表的查找
2. 基于树的查找法

计算式查找法又称hash(哈希）查找法

## 8.2基于线性表的查找法

### 8.2.1顺序查找法

#### 数据类型定义

```c
#define LIST_SIZE 20
typedef struct{
    KeyType key;
    OtherType other _data;
}RecordType;

typedef struct{
    RecordType r[LIST_SIZE+1];/*r[0]为工作单元*/
    int length;
}RecordList;
```

#### 顺序结构算法

【设置监视哨】

```c
int SeqSearch (RecordList l,KeyType k)
/*在顺序表l中顺序查找其关键字等于k的元素,若找到,则函数值为该元素在表中的位置，否则为0*/
{
    I.r[0].key=k;
    i=l.length;
	while (I.r[i].key!=k)
		i—-;
	return (i);
}
/*其中!.r[0]称为监视哨,可以起到防止越界的作用。*/
```

【不设置监视哨】

```c
int SeqSearch (RecordList I,KeyType k)
/*不用监视哨法，在顺序表中查找关键字等于k的元素*/
{
    i=l.length;
    while ( i>=1&&l.r[i].key!=k)
    i--;
    if ( i>=1) 
        return (i)
    else 
        return (O);
}
```



#### 性能分析

假设列表长度为n，那么查找第i个数据元素时需进行n-i+1次比较,即C~i~=n-i+1。又假设查找每个数据元素的概率相等,即P~i~=1/n，则顺序查找算法的查找成功时平均查找长度为:
$$
ASL_{succ}=\sum^n_{i=1}P_iC_i=\frac{1}{n}\sum_{i=1}^nC_i=\frac{1}{n}\sum_{i=1}^n(n-i+1)=\frac{1}{2}(n+1)
$$


### 8.2.2折半查找法

#### 定义

折半查找法又称为二分查找法，这种方法对待查找的列表有两个要求:(1)必须采用顺序存储结构;（2）必须按关键字大小有序排列。

#### 基本过程

将表中间位置记录的关键字与查找关键字比较:
如果两者相等，则查找成功;否则利用中间位置记录将表分成前、后两个子表:
如果中间位置记录的关键字大于查找关键字,则进一步查找前一子表;否则进一步查找后一子表。

#### 算法

```c
int BinSrchZ(SqList l, KeyType k)/*在有序表I中折半查找其关键字等于k的元素，若找到，则函数值为该元素在表中的位置*/
{
    low=1 ;
    high=l.length;/*置区间初值*/
	while( low<=high)
    {
		mid=(low+high)/2;
    if(k==l.r[mid]. key)
		return (mid);/*找到待查元素*/
	else if(k<l.r[mid]. key)
    	high=mid-1;/*未找到则继续在前半区间进行查找*/
    else
        low=mid+1 ;/*继续在后半区间进行查找*/
    }
    return (O) ;
}
```



#### 性能分析

折半查找过程可用一判定树描述

> 判定树结构:
> 树中每一结点表示表中一记录结点值记录在表中的位置
> 从根到被查结点路径关键字比较次数为被查结点层数
> 成功进行最多比较次数不超过树深度[log2 n] +1

假定表的长度n=2^h^-1，则相应判定树必为深度是h的满二叉树
h=log~2~(n+1)
又假设每个记录的查找概率相等，则折半查找成功时的平均查找长度
$$
ASL_{bs}=\sum^n_{i-1}p_ic_i=\frac{1}{n}\sum^n_{j=1}j\times2^{j-1}\\
ASL_{succ}=(1+2+2+3+3+3+3+4+4+4+4)\div11=3
$$


### 8.2.3分块查找法

#### 对所查表要求

1. 将列表分成若干个块(子表）,一般情况下,块的长度均匀,最后一块可以不满
2. 每块中元素任意排列,即块内无序
3. 块与块之间有序

#### 基本思想

1. 构造一个索引表
2. 将待查关键字K与索引表中的关键字进行比较，以确定待查记录所在的块。具体的可用顺序查找法或折半查找法进行
3. 用顺序查找法，在相应块内查找关键字为K的元素

【示例】

![](https://p.ananas.chaoxing.com/star3/origin/b05b0c6e736a91eece29a1e7308f7632.png?rw=1040&rh=437&_fileSize=94036&_orientation=1)

> 在上述索引顺序表中查找36。首先，将36与索引表中的关键字进行比较，因为25<36≤58，所以36在第二个块中，进一步在第二个块中顺序查找,最后在8号单元中找到36。

#### 平均查找长度

查找索引表的平均查找长度L~B~相应块内顺序查找的平均查找长度L~w~
平均查找长度: ASL~bs~=L~B~+L~w~假定将长度为n的表分成b块，每块含s个元素，则b=n/s.
又假定表中每个元素的查找概率相等，则每个索引项的查找概率为1/b，块中每个元素的查找概率为1/s。则有:

【顺序法平均查找长度】
$$
L_B=\frac{1}{b}\sum^b_{j=1}j=\frac{b+1}2\\
L_W=\frac{1}{s}\sum^s_{i=1}i=\frac{s+1}2\\
ASL_{bs}=\frac{1}{2}(\frac{n}{s}+s)+1=\frac{1}{2}(b+1+s+1)=\frac{1}{2}(b+s)+1
$$
【折半法平均查找长度】
$$
L_b&=&log_2(b+1)-1\\
ASL_{bs}&=&log_2(b+1)-1+\frac{s+1}{2}\\
&=&log_2(\frac{n}{2}+1)+\frac{s}{2}
$$


## 8.3 基于树的查找法

基于树的查找法是将待查表组织成特定树的形式并在树结构上实现查找的方法，故又称为树表式查找法，主要包括二叉排序树、平衡二叉树和B树等。

### 8.3.1二叉排序树

#### 定义

二叉树排序树或者是一棵空树，或者是具有如下性质的二叉树:

1. 若它的左子树非空，则左子树上所有结点的值均小于根结点的值
2. 若它的右子树非空，则右子树上所有结点的值均大于根结点的值
3. 它的左右子树也分别为二叉排序树。

![](https://p.ananas.chaoxing.com/star3/origin/0c154b2cc906e93475333c37610bf1f2.png?rw=716&rh=377&_fileSize=31262&_orientation=1)

#### 插入和生成

【插入方法】

1）若二叉排序树是空树，则key成为二叉排序树的根;
2)若二叉排序树非空，则将key与二叉排序树的根进行比较:
如果key的值等于根结点的值，则停止插入;
如果key的值小于根结点的值，则将key插入左子树;
如果key的值大于根结点的值，则将key插入右子树。

【建立算法示例】

```c
voidreateBST (BSTree *bst)
/*从键盘输入元素的值，创建相应的二叉排序树*/
{
    KeyType key;*bst=NULL;
	scanf (" %d"，&key) ;while (key !=ENDKEY)
    {
        InsertBST (bst，key) ;
        scanf ( " %d"，&key) ;
    }
}
```

```c
void lnsertBST (BSTree *bst,KeyType key)
{
	BiTree s;
	if(*bst==NULL)
        {
            s=(BSTree)malloc (sizeof (BSTNode)) ;
            s-> key=key;
            s->lchil d=NULL;
            s->rchild=NULL;
            *bst=s;
        }
	else if (key <(*bst)->key)
		InsertBST (&((*bst)->lchild), key) ;
	else if (key >(*bst)->key)
		InsertBST(& ((*bst)->rchild), key);
}
```

#### 查找

根据二叉排序树的特点,首先将待查关键字k 与根结点关键字t进行比较,如果:

1. key= t :则返回根结点地址;
2. key<t :则进一步查左子树﹔
3. key>t :则进一步查右子树。

查找算法:
【递归算法】

```c
BS Tree Sea rchBST(BSTree bst,Key Ty pekey)
{
    if ( ! bst ) 
        return NULL;
    else if ( b s t - >key ==k e y)
        return bst ;
    else if (bst ->key > key )
        return sear ch BST ( bst ->lchil d , k e y );
    else
        return search BST( bst ->rchil d , ke y );
}
```



【非递归算法】

```c
BSTree Sea rchBST (BSTree bst, Key Type key)
{
    BSTree q;
    q =bst ;while ( q )
    {
        if ( q- >key = =key)
        	return q;/*查找成功*/
        if (key < q-> key)
        	q=q->lchild ;
        else 
            q=q->rchild ;
    }
    return NULL;/*查找失败*/
}/ * SearchBST*/
```



#### 查找性能

平均查找长度和二叉排序树的形态有关
就平均性能而言，二叉排序树上的查找和二分查找相差不大，并且二叉排序树上的插入和删除结点十分方便，无需移动大量结点
【最坏情况】

![img](https://p.ananas.chaoxing.com/star3/origin/bdc275207390f07e09a9b9ff5e002f8b.png?rw=858&rh=725&_fileSize=103100&_orientation=1)

【最好情况】

![](https://p.ananas.chaoxing.com/star3/origin/956b8edd9b60edc77b3655dd538e79b5.png?rw=898&rh=660&_fileSize=87809&_orientation=1)

#### 删除

1）若p为叶结点，则可直接将其删除:f ->lchil d=NULL; free (p) ;
2)若p结点只有左子树，或只有右子树，则可将p的左子树或右子树,直接改为其双亲结点f的左子树。
即:f->lchil d=p->lchil d(或f->lchild=p->rchild );free (p) ;
3）若p既有左子树,又有右子树,此时有两种处理方法:



```c
BSTNode *DelBST(BSTree t, KeyType k)
{
    BSTNode *p， *f,*s ,*q;
	p=t;
    f=NULL;
	while(p)
		{
        	if(p->key==k )
                break;
        	f=p;
        	if (p->key>k)
                p=p->lchild;
        	else
                p=p->rchild;
		}
	if(p==NULL) 
        return t;
    if(p->lchild==NULL)
		{
        	if(f==NULL) 
                t=p->rchild;
        	else if(f->lchild==p)
				f->lchild=p->rchild ;
        	else f->rchild=p->rchild ;
        		free(p);
		}
	else /*p有左子树*/
    	{
        	q=p;
        	s=p->lchil d ;
            while (s->rchil d）/*在p的左子树中查找最右下结点*/
                {
                    q=s;
                    s=s->rchild;
                }
            if (q==p)
                   q->lchild=s-> lchil d;/*将s的左子树链到q上*/
            else q->rchild=s-> lchild;
                   p->key=s->key ;/*将s的值赋给*/
            free(s);
		}
	return t ;
}/*DelBST*/
```



### 8.3.2平衡二叉排序树

#### 定义

平衡二叉排序树又称为AVL树。一棵平衡二叉排序树或者是空树，或者是具有下列性质的二叉排序树:
(1)左子树与右子树的高度之差的绝对值小于等于1 ;
(2)左子树和右子树也是平衡二叉排序树。

#### 平衡因子

平衡因子( bal ance factor )即结点的左子树深度与右子树深度之差。对一棵平衡二叉排序树而言，其所有结点的平衡因子只能是-1、0、或1。

![](https://p.ananas.chaoxing.com/star3/origin/298890363fd61d7af885ca465ee5d0e2.png?rw=838&rh=507&_fileSize=84160&_orientation=1)

#### 失衡调整方法

==肝不动了==

#### 失衡类型及调整方法

==肝不动了==

#### 完整程序

```c
void ins_AVLtree ( AVLTree *avlt , KeyType k)
/*在平衡二义树中插入元素k，使之成为一棵新的平衡二叉排序树*/
{
	S=(AVLTree)malloc(sizeof(AVLTNode));
	S->key=k;
    s ->lchild-S->rchild=NULL;
    s ->bf=-0;
	if (*avlt==NULL)
        *avlt=S;
    else/*首先查找S的插入位置fp，同时记录距S的插入位置最近且平衡因子不等于0(等于-1或1）的结点A，A为可能的失衡结点*/
        A=*avlt;FA=NULL;
	p=*avlt ;
    fp=NULL;
    while (p !=NULL)
		{
			if (p ->bf!=O)
				{
					A=p;
					FA =fp;
				}
			fp=p;
			if(K<p->key)
                p=p ->lchild;
			else
                p=p ->rchild;/*插入S*/
 			if(K<fp->key)
                fp ->lchild=S;
			else
                fp->rchild=S;/*确定结点B，并修改A的平衡因子*/
			if(K<A->key)
				{
					B=A ->lchild;
					A->bf=A->bf+1;
				}
			else
				{
					B=A ->rchild;
					A->bf=A->bf-1;
				}/*修改B到S路径上各结点的平衡因子（原值均为0）*/
			p=B;
			while(p!=S)
				if (K<p->key) {p ->bf=1;
					p=p->lchild;
                  }else 
                	{p ->bf--1;p=p->rchild;}/*判断失衡类型并做相应处理*/
        
            if (A->bf==2 && B->bf==1)/*LL型*/
                {
                    B=A->lchild;
                    A->lchild=B->rchild;
                    B->rchild=A;
                    A->bf-0;
                    B ->bf=0;
                    if (FA=-NULL) 
                        *avlt=B ;
                    else if(A==FA->Ichild)
                        FA ->lchild=B;
                    else FA->rchild-B;
                }

            else if(A->bf-=2 && B->bf-=-1)/*LR型*/
                {
                    B=A->lchild;
                    C-B ->rchild;
                    B->rchild=C->lchild;
                    A->lchild=C->rchild;
                    C->lchild=B;
                    C ->rchild=A;
                    if (S->key <C->key)
                        {
                            A->bf--1;B->bf-0 ;
                            C->bf=0; 
                        }
                    else if(S->key >C->key)
                        {
                            A->bf=0;
                            B->bf=1 ;
                            C ->bf-0;
                        }
                    else
                        {
                            A->bf=0;
                            B->bf=0 ;
                        }
                    if(FA==NULL)
                        *avlt=C;
                    else if (A==FA->1child)
                        FA ->lchild=C;
                    else 
                        FA ->rchild=C;
                }

            else if(A->bf-=-2&&B->bf-=1)/*RL型*/
                {
                    B=A->rchild;
                    C=B ->lchild;
                    B->lchild=C->rchild;
                    A->rchild-C->lchild;
                    C->lchild=A;
                    C ->rchild-B;
                    if (S->key<C->key)
                        {
                            A->bf=0;
                            B->bf=-1; 
                            C->bf=0;
                        }
                    else if(S->key >C->key)
                        {
                            A->bf=1;
                            B->bf-0 ; 
                            C->bf=0;
                        }
                    else
                        {
                            A->bf-0;
                            B->bf-0 ; 
                        }
                    if(FA==NULL) 
                         *avlt=C;
                    else if(A==FA->lchild) 
                        FA ->lchild=C;
                    else 
                        FA ->rchild=C;
                }

            else if (A->bf==-2 && B->bf==-1)/*RR型*/
                {
                    B=A->rchild;
                    A->rchild=B->lchild;
                    B->lchild=A;
                    A->bf=0;
                    B ->bf=O;
                    if (FA=-NULL) 
                        *avlt=B ;
                    else if(A=-FA->lchild)
                        FA ->lchild=B;
                    else 
                        FA->rchild=B;
                }
		}/*WHILE*/
}
```



### 8.3.3B树

m路查找树

一棵m路查找树,或者是一棵空树，或者是满足如下性质的树:

1. 结点最多有m棵子树.m-1个关键字.其中n为关键字个数，P~i~(0≤i≤n)为指向子树根结点的指针，K~i~(1≤i≤n)为关键字，
2. K~i~<K~i+1~，1≤i≤n-1
3. 子树Pi中的所有关键字均大于K~i~ 、小于K~i~+1，1≤i≤n-1
4. 子树P~0~中的关键字均小于K~1~，而子树P~n~中的所有关键字均大于Kn
5. 子树P~i~也是m路查找树，0≤i≤n

B树及其查找

定义

一棵B树是一棵平衡的m路查找树，它或者是空树，或者是满足如下性质的树:
(1）树中每个结点最多有m棵子树;(2）根结点至少有两棵子树;
(3）除根结点之外的所有非叶结点至少有棵
子树;
(4)所有叶结点出现在同一层上，并且不含信
息，通常称为失败结点。失败结点为虚结点，在B树中并不存在，指向它们的指针为空指针。引入失败结点是为了便于分析B树的查找性能。



查找

==肝不动了==

插入

==肝不动了==

删除

==肝不动了==

## 8.4计算式查找法--哈希法

### 哈希的基本思想

基本思想:

(1)哈希函数
建立哈希函数:p=H(key)，计算关键字key在哈希表的中的存储位置p。
(2)冲突
冲突问题:若关键字key1 key2，哈希函数值H(key1)= H(key2)，则发生冲突。
冲突原因:
(1）必然性:由于关键字可能的取值空间远远大于哈希表的地址空间，冲突不可避免。
(2）可能性:哈希函数H(key)的散列性能不好，可能加剧冲突发生。
哈希法既是一个建表方法，也是一个查表方法。

### 8.4.1哈希函数的构造方法

原则

①函数本身便于计算;
②计算出来的地址分布均匀。
1.数字分析法

从关键字中选出分布较均匀的若干位，构成哈希地址
例如假设关键字中 d4和d7的取值分布较均匀，则哈希函数为:

h(key)=h(d1d2d3---d7d8)=d4d7
h(81346532)=43,
h(81301367)=06

2.平方取中法

先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。

| 关键字 | 内部编码 | 内部编码的平方值 | H(k)哈希地址 |
| ------ | -------- | ---------------- | ------------ |
| KEYA   | 11050201 | 122157778355001  | 778          |
| KYAB   | 11250102 | 126564795010404  | 795          |
| AKEY   | 01110525 | 001233265775625  | 265          |


平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。

3.分段叠加法

按哈希表地址位数将关键字分成位数相等的几部分（最后一部分可以较短），然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。

【折叠法】

从一端向另一端沿分割界来回折叠（奇数段为正序，偶数段为倒序），然后将各段相加.例如: key=12360324711202065,哈希表长度为1000，舍去最低的两位65

【移位法】

将分割后的每部分低位对齐相加
例如: key=12360324711202065,哈希表长度为1000，舍去最低的两位65

4.除留余数法

假设哈希表长为m，p为小于等于m的最大素数，则哈希函数为
h(k) =k%p ，其中%为模p取余运算例如，已知待散列元素为（18，75，60，43,54，90，46），表长m=10，p=7，则有

- h(18)%7=4
- h(60)%7=4
- h(54)%7=5
- h(46)%7=4

为减少冲突，取较大的m值和p值，m=p=13

- h(18)%7=5
- h(60)%7=8
- h(54)%7=2
- h(46)%7=7

5.伪随机数法

采用一个伪随机函数做哈希函数，即h(key)=random(key)。

### 8.4.2处理冲突的方法

#### 开放定址法

【基本思想】:

当关键字key的哈希地址p=H (key）出现冲突时.以p为基础立生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi，将相应元素存入其中。
通用的再散列函数形式:
Hi= (H(key) +di ) % m

1线性探测再散列

```
Hi= (H(key) +di) % m
di=1，2，3，…，m-1
特点:冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表
例如:已知哈希表长度m=11，哈希函数为:
H (key） = key %11,
则H(47）=3，H (26）=4，H (60） =5，假设下一个关键字为69，则H (69） =3，与47冲突
```

2二次探测再散列

```
Hi= (H (key) +di) % m
di=12，-12，22，-22，"…，k2，一k2
特点:冲突发生时，在表的左右进行跳跃式探测，比较灵活
例如:已知哈希表长度m=11，哈希函数为:
H(key) = key %11,
则H(47） =3，H (26）=4，H(60）=5，假设下一个关键字为69，则H(69） =3，与47冲突
```

3伪随机探测再散列

```
Hi= (H (key) +di) % mdi=伪随机数序列
例如:已知哈希表长度m=11，哈希函数为:
H (key） = key %11,
则H(47）=3，H(26）=4，H (60）=5，假设下一个关键字为69，则H(69）=3，与47冲突
```



#### 再哈希法

同时构造多个不同的哈希函数:Hi=RH1 (key)
i=1，2，..., k
当哈希地址Hi=RH1 (key）发生冲突时，再计算Hi=RH2 (key） ….….直到冲突不再产生。
这种方法不易产生聚集，但增加了计算时间。

#### 链地址法

例如，已知一组关键字(32，40，36,53，16，46，71，27，42，24，49,64），哈希表长度为13，哈希函数为:H (key） = key % 13

![](https://p.ananas.chaoxing.com/star3/origin/15b59477a12ca399612aedfe315bbdd7.png?rw=648&rh=566&_fileSize=71762&_orientation=1)

#### 建立公共溢出区

基本思想:
将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

### 8.4.3哈希表的查找过程

#### 1．查找过程

哈希表的查找过程与哈希表的创建过程是一致的。
当查找关键字为K的元素时,

1.计算p0= hash (K) ;
2．如果单元p0为空，则所查元素不存在﹔
3．如果单元p0中元素的关键字为K，则找到所查元素﹔
4．否则重复下述解决冲突的过程:
按解决冲突的方法,找出下一个哈希地址pi
a）如果单元pi为空，则所查元素不存在﹔
b )）如果单元pi中元素的关键字为K，则找到所查元素。

#### 2．查找算法

```c
intHashSearch( HashTable ht, KeyType K)
{
    p0=hash(K);
    if(ht[p0].key==NULLKEY)
      return (-1);
    else if(ht [p0]. key==K)
    	return (p0) ;
    else
    {
        for (i=1 ; i<=m-1 ;i++)
            {
                pi=(pO+i) % m;
                if(ht[pi ].key==NULLKEY)
                    return (-1);
                else if(ht [pi].key==K)
                    return (pi);
            }
        return (-1);
    }
}
```



### 8.4.4哈希法性能分析

影响比较次数的因素:1哈希函数
2处理冲突的方法3装填因子
哈希表的装填因子α的定义如下:
a =哈希表中元素个数/哈希表的长度
a可描述哈希表的装满程度。显然,α越小，发生冲突的可能性越小，而α越大，发生冲突的可能性也越大
手工计算等概率情况下查找成功的平均查找长度公式
$$
ASL_{SUCC}=\frac{1}{表中置入元素个数n}\sum^n_{i=1}C_i
$$
手工计算在等概率情况下查找不成功的平均查找长度公式
$$
ASL_{SUCC}=\frac{1}{哈希函数取值个数r}\sum^{r-1}_{i=0}C_i
$$


## 8.5总结与提高

### 主要知识点

#### 查找表的检索机制

本章给出了三种类型的查找表:
第一类是线性索引，记录关键字一般按序排列，以提高检索速度，对应检索采用基于比较检索方法;
第二类是树形索引，树形的典型结构是二叉排序树，其检索的时间复杂度与树的深度同级为对数函数，其对应的检索方法是基于树表式的检索，即将待查找的表组织成树、在树形结构上实现查找;
第三类是散列（哈希）结构，根据数据的关键值“计算”数据的存储地址。散列（哈希）表既是建立表也是查找表的方法，其对应的检索方法是“计算式”的检索。

#### 平均查找长度

为确定数据元素在列表中的位置,需和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的平均查找长度。
计算平均查找长度的基本公式:
对于长度为n的列表，查找成功时的平均查找长度为:
$$
ASL=P_1C_1+ P_2C_2+\cdots+ P_nC_n=\sum^n_{i=1}p_ic_i
$$
其中P;为查找列表中第i个数据元素的概率，C为找到列表中第i个数据元素时，已经进行过的关键字比较次数。计算方法:
采用公式法计算(通用)，也可采用手工计算方式(具体),针对实际的具体问题,计算相应的查找成功时的平均查找长度。

#### 折半查找

折半查找法要求待查找表应采用顺序存储结构且按关键字有序排列。
折半查找过程借助于折半判定树加以描述。判定树中每一结点对应表中一个记录在表中的位置序号
折半查找算法的性能:在等概率时查找成功的平均查找长度与折半判定树的深度相关，
ASL~bs~ ≈ log~2~(n+1)-1
折半查找算法查找速度快,平均性能好;插入删除较困难。

#### 二叉排序树

掌握二叉排序树的定义.
理解二叉排序树的性质:中序遍历一个二叉排序树可以得到一个递增有序序列。
含有n个结点的二叉排序树形态不唯一,其构造与数列的输入顺序有关。
查找过程与折半查找过程类似，在二叉排序树中查找一个记录时,其比较次数不超过树的深度。就平均性能而言，二叉排序树上的查找和折半查找相差不大
平均查找长度仍然是O(log~2~n)
二叉排序树的插入、删除操作无需移动大量结点,经常变化的动态表宜采用二叉排序树结构。

#### 哈希法

基本思想:以元素的关键字k为自变量，通过哈希函数H,计算其存储位置p即p=H(k)，从而实现按关键字计算的方式建立表与查找表.哈希表的查找过程与哈希表的创建过程对应一致。
哈希法主要包括:1)哈希函数构造,2)处理冲突方法。构造哈希函数常用的方法有除留余数法。处理冲突的基本方法包括线性探测再散列、二次探测再散列、链地址法等。哈希法中影响关键字比较次数的因素有三个:哈希函数、处理冲突的方法以及哈希表的装填因子。哈希表的平均查找长度是装填因子α的函数。

### 典型题解

#### 例1设计哈希表

【例1 】1000个记录设计哈希表，假设哈希函数是均匀的,解决冲突用线性探测再散列法，并要求在等概率情况下查找成功时的ASL不超过3，查找不成功时的ASL不超过13,则哈希表长度m应取多大?
【解】本题要求应用公式计算平均查找长度。
已知哈希函数是均匀的，且解决冲突用线性探测再散列法时，在等概率情况下查找成功和查找不成功时的平均查找长度为:1
$$
ASL_{succ}\approx\frac{1}{2}(1+\frac{1}{1-a})\\ASL_{unsucc}\approx\frac{1}{2}(1+\frac{1}{(1-a)^2})
$$

$$
\frac{1}{2}(1+\frac{1}{(1-a)})\leq3\\\frac{1}{2}(1+\frac{1}{(1-a)^2})\leq13
$$

解得a≤0.8，取α=0.8，由于0.8=1000/m，所以m=1250。



#### 例2建立哈希表

【例2】对以下关键字序列建立哈希表:(SUN,MON,TUE,WED,THU, FRI,SAT），哈希函数为H(K)= (K中第一个字母在字母表中的序号）MOD 7。用线性探测法处理冲突，要求构造一个装填因子为0.7的哈希表，并计算出在等概率情况下查找成功的平均查找长度和不成功的平均查找长度。

【解】此题主要要求掌握手工计算平均查找长度方法。装填因子为0.7，根据公式:装填因子=元素个数/表长，知哈希表长度=7/0.7=10。
各关键字第一个字母的序号分别为19(S)、13(M)、20(T)、23(W)、6(F)。
建立哈希表

![](https://p.ananas.chaoxing.com/star3/origin/5513384049d636606d27c0d08d64d7a8.png?rw=1300&rh=834&_fileSize=197279&_orientation=1)

成功的平均查找长度

![](https://p.ananas.chaoxing.com/star3/origin/dbc77a808cb9d1fc4e62092209697899.png?rw=1316&rh=879&_fileSize=245537&_orientation=1)

不成功的平均查找长度

![](https://p.ananas.chaoxing.com/star3/origin/3077f2b30aee8c48867e68acd55736b7.png?rw=1265&rh=833&_fileSize=284234&_orientation=1)

#### 例3手工求平均查找长度

【例3】已知某哈希表的装载因子小于1，哈希函数H(key)为关键字(标识符)的第一个字母在字母表中的序号，处理冲突的方法为线性探测开放定址法。

①编写按第一个字母的顺序输出哈希表中所有关键字的算法。

②编写模拟手工计算等概率情况下查找不成功的平均查找长度算法。

【解①】【问题分析】

实现步骤:
1.对字母序号为i，可先从该字母序号位置开始判断该处所存关键字的哈希函数值是否为i
2.若相同，则表示该关键字为与序号i对应的关键字，输出该值;
3.若不同，表示该关键字并非为字母序号i对应的关键字,不输出;
4.按线性探测开放定址法继续判断下一个关键字，直到值为空;
5.字母序号从1到26持续上述步骤,则可得一个按字母顺序输出的所有关键字序列。

【算法描述】

```c
void printword(HashTable ht)
{
	int i, j;
	for( i=1; i<=26; i++)/*字母序号从1到26 输出所有关键字序列*/
		{
			j = i ;/*从字母序号为i的位置开始判断*/
			while(ht[j].key != NULLKEY)
				{
					if(hash(ht[j].key) == i)/*若该关键字的哈希地址为i，则输出该关键字*/
						printf ("%s \n" , ht[j].key);
					j = (j+1) %m;/*按线性探测处理冲突*/
				}
		}
}
```

根据手工计算等概率情况下查找不成功的平均查找长度公式
$$
ASL_{UNSUCC}=\frac{1}{哈希函数取值个数r}\sum^{r}_{i=1}C_i
$$
知模拟手工计算查找不成功的平均查找长度可分为3步实现:

1.求得每个关键字的查找不成功的比较次数,设一个计数器count记录比较次数;

2.把对应每个关键字的比较次数相加得总的比较次数;

3.将总的比较次数除以哈希函数取值个数就可得查找不成功的平均查找长度。

---

# 第9章内部排序

## 9.1排序的基本概念

### 排序

记录序列:
{R~1~，R~2~，...，R~n~}

关键字序列:
{K~1~，K~2~,...，K~n~ }
重排记录序列，得:{R~p1~，R~p2~，...，R~pn~}使相应关键字满足非递减(或非递增）关系，即:K~p1~≤ K~p2~<...≤ K~pn~

### 内部排序与外部排序

根据排序时数据所占用存储器的不同，可将排序分为两类。
【内部排序】

整个排序过程完全在内存中进行，称为内部排序

【外部排序】

由于待排序记录数据量太大，内存无法容纳全部数据，排序需要借助外部存储设备才能完成，称为外部排序。

### 排序的稳定性

【稳定排序】

在排序过程中，相同关键字(K~i~=K~j~ i<j )其领先关系不发生变化者，称为稳定。
稳定性证明
要从算法本身的步骤中加以证明。

【不稳定排序】

在排序过程中，相同关键字(Ki=K;, i<j)其领先关系发生变化者，称为不稳定。
不稳定证明
只需给出一个反例说明

### 基本操作

1. 比较两个关键字的大小.
2. 将记录从一个位置移动到另一个位置

操作(1）对于大多数排序方法来说是必要的操作（2）则可通过采用适当的存储方式予以避免

### 存储方法

(1)向量结构

将待排序的记录存放在一组地址连续的存储单元。

⑵)链表结构

记录之间逻辑上的相邻性是靠指针来维持的,在排序时，不需要移动记录元素，只需要修改指针。

⑶)地址排序

记录向量与地址向量结合

1. 将待排序记录存放在一组地址连续的存储单元中
2. 设一个指示各个记录位置的地址向量
3. 排序过程中不移动记录本身，只修改地址向量中记录的"地址"
4. 排序后，按照地址向量中的值调整记录的存储位置

## 9.2插入类排序

### 插入排序基本思想

在一个已排好序的记录子集的基础上，每一步将下一个待排序的记录有序插入到已排好序的记录子集中，直到将所有待排记录全部插入为止。

### 9.2.1直接插入排序

【算法思想】

将第i个插入到前i-1个有序集合

K~i~与K~i-1~，K~i-2~,...K~1~依次比较将关键字大于K~i~的记录依次后移一位置，直到遇到一个小于或等于K~i~的关键字K~j~，K~j +1~必为空

将第i个记录插入到空位置。

【算法要点】

- ①监视哨r[0]保存待插入的记录
- ②从后往前查找应插人的位置
- ③查找与移动用同一循环完成。

【算法实现】

```c
void InsSort(RecordTyper[,int length)
/*对记录数组r做直接插人排序，length为数组的长度*/
{
     for(i=2;i< length;i++ )
          {
               r[0]=r[i];
               j=i-1;/*将待插入记录存放到监视哨r[0]中*/
               while(r[0].key<r[i].key)
                    {	/*寻找插人位置*/
                         r[j+1]= r[i];
                         j=j-1;
                    }
               r+1]=r[0];/*将待插人记录插人已排序的序列中*/
          }
}/*InsSort */
```



【算法分析】

最好情况

> 有序的待排序序列
> 比较次数:n-1次移动次数:2(n-1)次

最坏情况

待排序记录为逆序排列总比较次数:
$$
\sum^n_{i=2}i=\frac{(n+2)(n-1)}{2}
$$
记录移动次数:
$$
\sum^n_{i=2}(i+1)=\frac{(n+4)(n-1)}{2}
$$
故直接插入排序的时间复杂度为T(n)=O(n^2^)

算法改进思路:减少关键字比较次数,减少移动记录次数.



证明一种排序方法是稳定的，要从算法本身的步骤中加以证明。
问题:直接插入排序的稳定性?

回答:排序比较从后向前进行∵算法while(r[0].key<r[i].key).∴相同关键字相对位置不会改变

### 9.2.2折半插入排序

【算法思想】

将折半查找用于在有序记录集r[1..i-1]中确定插入位置，将相应的排序法称为折半插入排序法

【算法描述】

```c
void BinSort(RecordType r[],int length)/*对数组r进行折半插人排序，length为数组的长度*/
{
for(i=2 ;i<=length;++i)
{
	x= r[i];
	low=1; high=i-1;
  while(low<=high)/*确定插入位置*/
    {
      mid=(low+high) / 2;
      if(x.key< r[mid].key )
        high=mid-1;
      else 
        low=mid+1
    }
    for(j=i-1;j>=low;--j )
      r[j+1]= r[i];/*记录依次向后移动*/
    r[low]=x;
/*插人记录*/
}
```



【算法分析】

折半插入排序可减少关键字的比较次数。每插人一个元素，需要比较的次数最大为折半判定树的深度

### 9.2.3希尔排序

【算法改进要点】

1)将记录序列分成若干个子序列分别进行直接插入排序
2)经多次调整序列记录已基本有序最后再对记录进行直接插入排序

【算法思想】

1.对整个文件，按间隔d1分组，组内排序
2取d2<d1(缩小增量)，继续以d2为距离排序,直到dt=1(同直接插人排序)为止。

![](https://p.ananas.chaoxing.com/star3/origin/668f5fc8bb20b373b631717325b31f96.png?rw=915&rh=597&_fileSize=74704&_orientation=1)

【算法描述】

```c
void Shelllnsert(RecordType rl]，int length,int delta)/*对记录数组r做一趟希尔插入排序，length为数组的长度，delta为增量*/
{
  for ( i=1+delta; i<=length; i++)/*1+delta为第一个子序列的第二个元素的下标*/
    if(r[i].key<r[i-delta]. key)
			{
				r[O]=r[i];/*备份r[i](不做监视哨)*/
				for(j=i-delta;
						j>0 &&r[O].key<r[j].key;
						j-=delta)r[j+delta]=r[jl;
						r[j+delta]=r[O];
      }
}/*Shelllnsert*/
                                  
void ShellSort(RecordType r[],int length,int delta[],int n)/*对记录数组r做希尔排序，length为数组r长度，delta为增量数组，n为delta的长度*/
{
  for(i=0; i<=n-1 ; ++i)
	Shelllnsert(r，Length,delta[i]);
}

```



【算法分析】

增量的取法
关于增量d的取法，最初Shell提出取d=n/2,d=d/2,直到d=1为止。该思路的缺点是，在奇数位置的元素在最后一步才会与偶数位置的元素进行比较,使得希尔排序效率降低。因此后来Knuth提出d=d/3+1。



逆转数
对于待排序序列中的某个记录的关键字，它的逆转数是指在它之前比此关键字大的关键字的个数


时间复杂度约为0(n^1.5^)



希尔稳定性排序的稳定性如何?
在希尔排序过程中，相同关键字记录的领先关系发生变化，说明该排序方法是不稳定的。

### 小结

![](https://p.ananas.chaoxing.com/star3/origin/7e5f001bc733042002a64a186acbff3a.png?rw=1137&rh=640&_fileSize=85617&_orientation=1)

| 排序算法 | 稳定性 | 证明                                                         |
| -------- | ------ | ------------------------------------------------------------ |
| 直接插入 | 稳定   | 从本身证明<br/>排序比较从后向前进行算法while(r[O].key<r[i].key) |
| 希尔排序 | 不稳定 |                                                              |
| 折半排序 | 稳定   | if(x.key<r[mid].key)                                         |



## 9.3交换类排序法

### 9.3.1冒泡排序(相邻比序法)

【算法思想】

每次扫描顺次比较相邻的两个元素的大小,
若逆序就交换位置,反复扫描,
直到待排序记录序列没有逆序为止.

【算法描述】

```c
void BubbSort (Record r[ ],int length )
{
  n=length;change=TRUE;
  for ( i=1;i<=n-1&&change; ++i )
    {
      change=FALSE;
      for ( j=1 ; j<= n-i ; ++j)
        if (r[j].key> rLj+1].key )
          {
            x= r[j];
            r[j]=_r[j+1];r[j+1]= x;
            change=TRUE;
          }
    }
}
```



【算法分析】

最坏情况待排序记录按关键字的逆序进行排列，每一趟冒泡排序需进行i次比较，3i次移动经过n-1趟冒泡排序后,
比较次数\sum>i=n (n-1)/2

移动次数3n(n-1)/2次

时间复杂度O(n^2^)

空间复杂度O(1)

### 9.3.2快速排序

【改进要点】

由于冒泡排序扫描过程中只对相邻的两个元素进行比较，因此在互换两个相邻元素时只能消除一个逆序。
如果能通过两个不相邻元素的交换,消除多个逆序，则会大大加快排序的速度。
快速排序方法中的一次交换可能消除多个逆序。

【算法思想】

从待排序记录序列中选取一个记录,其关键字设为K1,将其余关键字小于K1的记录移到前面,而将关键字大于K1的记录移到后面，结果将待排序记录序列分成两个子表，最后将关键字为K1的记录插到其分界线的位置处。
对分割后的两个子表继续按上述原则进行分割，直到所有子表的表长不超过1为止。

【算法描述】

```c
void QKSort(RecordType r[,intlow, int high )
{
  if(1ow<high)
    {
      pos=QKPass(r, low, high);
      QKSort(r, low, pos-1);
      QKSort(r, pos+1, high);
    }
}
```

```c
int QKPass (RecordType r[],int left,int right)
{
  x= r[left];
  low=left ;
  high=right;
  while ( low<high )
    {
    while(low<high&&r[high].key>=x.key)
      high --;
    if ( low <high )
      {
        r[low]= r[high] ;
        low++;
      }
    while (low<high&&r[low].key<x.key)low++;
      if (low<high )
        {
          r[high]= r[low];
          high--; 
        }
    }
  r[low]=x;.
  return low;
}/*QKPass */
```



【算法分析】

最好情况

每趟将序列一分两半，正好在表中间，将表分成两个大小相等的子表，类似折半查找，其时间复杂度分析如下:
![](https://p.ananas.chaoxing.com/star3/origin/f2f99e71a4e0425a2212e89d0cd0abbe.png?rw=858&rh=600&_fileSize=106671&_orientation=1)



最坏情况

已经排好序共需进行n-1趟排序,其比较次数为:
$$
\sum(n-i)=\frac{n(n-1)}{2}
$$
执行次数
$$
T(n)\leq n log_2n+nT(1)\approx O(nlog_2n)
$$

## 9.4 选择类排序法

### 选择排序基本思想

每一趟在n-i+1 (i=1，2,n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。

### 9.4.1简单选择排序

【算法思想】

第i趟简单选择排序是指通过n-i次关键字的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录进行交换。共需进行n-1趟简单选择排序，直到所有记录排序完成为止。

【算法描述】

```c
void SelectSort(RecordTyper[], int n
/*对记录数组r做简单选择排序,n为数组的长度*/
{
  for(i=1;i<= n-1 ;++i)
    {
      k=i;
      for(j=i+1;j<= n;++j)
        if(r[i].key<r[k].key)
          k=j;
      if(k!=i)
        {
          x= r[i];
          r[i]=r[k];
          r[k]=x;
        }
    }
}/* SelectSort */
```



【算法分析】

最好情况
待排序记录初始状态就已经是正序排列了，则不需要移动记录。

最坏情况

待排序记录初始状态是按逆序排列的,则需要移动记录的次数最多为3 ( n-1) 。

时间复杂度

简单选择排序过程中需要进行的比较次数与初始状态下待排序的记录序列的排列情况无关。
当i=1时，需进行n-1次比较;当i=2时，需进行n-2次比较;依次类推，需要的比较次数为:
$$
\sum^{n-1}_{i-1}n-i=(n-1)+(n-2)+\cdots+2+1=n(n-1)/2
$$
即进行比较操作的时间复杂度为O(n^2^)。

### 9.4.2树形选择排序

【算法改进要点】

简单选择排序中
n个记录中选择关键字最小的记录需n-1次比较n-1记录中选择关键字最小的记录需n-2次比较

由于每次都没有利用上次比较的结果，故比较操作的时间复杂度为O(n^2^)。

我们可以把比较过程中的大小关系保存下来。

【基本思想】

1. 把待排序的n个记录的关键字两两进行比较，取出较小者。
2. 在[n/2]个较小者中，采用同样的方法进行比较选出每两个中的较小者。
3. 如此反复，直至选出最小关键字记录为止。

【算法分析】

含有n个叶子节点的完全二叉树的深度log~2~n +1，则树型选择排序中，每选出一个较小关键字需进行[og~2~n次比较，其时间复杂度为O(nlog~2~n) 。
移动记录次数不超过比较次数。总的时间复杂度为O(nlog~2~n ) 。
与简单选择排序相比较降低了比较次数的数量级,增加了n-1个额外的存储空间存放中间比较结果,附加了与无穷进行比较的时间耗费。

### 9.4.3堆排序

【算法改进要点】

堆排序是在简单排序的基础上,将向量中存储的数据看成一棵完全二叉树，利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择关键字最小的记录。

【算法思想】

**堆**

待排序的记录的关键字存放在数组r[1..n]之中，将r看成是一棵完全二叉树的顺序表示，每个结点表示一个记录，任意结点r[0]的左孩子是r[2i],右孩子是r[2i+1],双亲是r[i/2]。对这棵完全二叉树进行调整，使各结点的关键字值满足下列条件:
r[i].key≥r[2i].key并且
r[i].key≥r[2i+1].key(i=1,2,... ),满足此条件的完全二叉树为堆。

**大根堆**

维中根结点的关键字最大，称为大根堆

![](https://p.ananas.chaoxing.com/star3/origin/021099ab20c43bf3a37935e1f4f6e6fb.png?rw=824&rh=575&_fileSize=80391&_orientation=1)

**小根堆**

完全二叉树中任意结点的关键字小于或者等于其左孩子和右孩子的关键字（当有左孩子或右孩子时)，对应的堆为小根堆

![](https://p.ananas.chaoxing.com/star3/origin/9ad49e49b825fe455d356d20f154b40a.png?rw=822&rh=551&_fileSize=77730&_orientation=1)

【堆排序问题】

以大根堆为例
<u>重建堆</u>

算法步骤

1）将完全二叉树根结点中的记录移出，此时根结点相当于空结点。从空结点的左、右孩子中选出一个关键字较小的记录，如果该记录的关键字小于待调整记录的关键字，则将该记录上移至空结点中。重复上述移动过程,直到空结点左、右子的关键字均不小于待调整记录的关键字。此时，将待调整记录放入空结点即可。

算法描述

```c
void sift(RecordType r[],int k ,int m)
  /*假设r [k..m]是以r [k]为根的完全二叉树，且分别以r[2k]和r [2k+1]为根的左、右子树为大根堆，调整r[k]，使整个序列r[k..m]满足堆的性质*/
  {
    t=r[k]﹔/*暂存"根"记录r[k]*/
    x=r[k].key;
    i=k;
    j=2*i;
    finished=FALSE;
    while(j<=m && ! finished )
      {
        if(j<m && r[j].key< r[j+1].key )
          jj+1;/*若存在右子树且根的关键字大则沿右分支"筛选"*/
        if(x>= r].key)
          finished=TRUE;
        /*筛选完毕*/
        else 
          {
            r[i]= r[i];
            i=j;
            j=2*i;
          }/*继续筛选*/
      }
    r=t;/*r[k]填人到恰当的位置*/
  }/*sift */
```



<u>建初堆</u>

如何由一个任意序列建初堆?
算法步骤

一个任意序列看成是对应的完全二叉树，由于叶结点可以视为单元素的堆，因而可以反复利用"筛选"法，自底向上逐层把所有子树调整为堆，直到将整个完全二叉树调整为堆。
可以证明，最后一个非叶结点位于[n/2]个元素，n为二叉树结点数目。因此，"筛选"须从第[n/2]个元素开始,逐层向上倒退，直到根结点。

算法描述

```c
void crt_heap(RecordType r[,int length )/*对记录数组r建堆,length为数组的长度*/
{
n= length;
for( i=n/2 ; i>= 1 ; --i)
/*自第个记录开始进行筛选建堆*/
sift(r，i, n);
}
                           
void sift(RecordType r[,int k ,int m)
{
  t=r[k];/*暂存"根"记录r[k]*/
  x=r[k].key;
  i=k;j=2*i;
  finished=FALSE;
  while( j<=m && ! finished )
    {
      if(j<m && r[ij].key< r[j+1].key )
        j=j+1;
      if(x>= rli].key)
        finished=TRUE;
      else
        {
          r[i]= ri;
          i=j;
          j=2*i;
        }/*继续筛选*/
    }
  r=t; /*r[k]填人到恰当的位置*/
}/* sift */
```

<u>堆排序算法实现</u>

算法步骤

①将待排序记录按照堆的定义建初堆，并输出堆顶元素

②调整剩余的记录序列，利用筛选法将前n-i个元素重新筛选建成为一个新堆,再输出堆顶元素

③重复执行步骤n-1次进行筛选,新筛选成的堆会越来越小，而新堆后面的有序关键字会越来越多，最后使待排序记录序列成为一个有序的序列，这个过程称之为堆排序。

算法描述

```c
void HeapSort (RecordTyper,int length)
/*对r[1..n]进行堆排序，执行本算法后，r中记录按关键字由大到小有序排列*/
{
  crt_heap ( r, length) ;
  n= length;
  for(i=n;i>= 2;--i)
    {
      b=r[1];/*将堆顶记录和堆的最后一个记录互换*/
      r[1]=r[i];
      r[=b;
      sift(r，1，i-1) ;/*进行调整，使r[1..i-1]变成堆*/
    }
}/*HeapSort */
```

算法分析

1. 堆排序在最坏情况下，其时间复杂度也为O(nlog~2~n)。
2. 堆排序与树型排序相比较,排序中只需要存放一个记录的辅助空间,因此也将堆排序称作原地排序。
3. 堆排序是一种不稳定的排序方法,它不适用于待排序记录个数n较少的情况，但对n较大的文件还是很有效的。

## 9.5归并排序

【基本思想】

假设初始序列含有n个记录，首先将这n个记录看成n个有序的子序列，每个子序列的长度为1，然后两两归并,得到个长度为2 (n为奇数时,最后一个序列的长度为1）的有序子序列。在此基础上，再对长度为2的有序子序列进行两两归并，得到若干个长度为4的有序子序列。
如此重复，直至得到一个长度为n的有序序列为止。
这种方法被称作2-路归并排序。

![](https://p.ananas.chaoxing.com/star3/origin/2e494ecba13643f075bacda51782ff04.png?rw=1356&rh=534&_fileSize=119899&_orientation=1)

【算法描述】

> 一趟合并算法

```c
void Merge( RecordType r1[],int low,intmid,int high, RecordType r[])
{
  i=low; j=mid+1;k=low ;
  while((i<=mid)&&(j<=high))
    {
      if (r1[i].key<=r1[j].key)
        {
          r[k]=r1[i];
          ++i;
        }
      else
        {
          r[k]=r1[j];
          ++j;
        }
      ++k;
    }
  while(i<=mid)
    {
      r[k]=r1[i];
      k++，i++;
    }
  while(j<=high);
    {
      r[k]=r1[j];
      k++;
      j++;
    }
}/*Merge */
```

> 归并算法

```c
void MSort (RecordTyper1[，int low,int high,RecordType r3[])
/*r1[low.. high]经过排序后放在r3[low. . high]中，r2[low. .high]为辅助空间*/
{
  RecordType r2[N];
  if ( low==high )
    r3[low]=r1[low];
  else
    {
      mid=(low+high)/2;
      MSort(r1，low,mid, r2);
      MSort(r1，mid+1，high, r2);
      Merge (r2， low,mid，high，r3);
    }
}/* MSort */
```

> 初始调用过程

```c
void MergeSort( RecordType r[ ],int n )
  /*对记录数组r[1..n]做归并排序*/
{
	MSort ( r， 1，n,r );
}
```



【算法分析】

一趟归并排序的操作是调用[n/2h]次算法merge将r1[1..n]中前后相邻且长度为h的有序段进行两两归并，得到前后相邻、长度为2h的有序段,并存放在r[1..n]中，其时间复杂度为O(n)。整个归并排序需进行m (m=log~2~n）趟2-路归并,总的时间复杂度为
O(nlog~2~n)，空间复杂度为O(n)。
归并排序的最大特点是,它是一种稳定的排序方法。并归排序主要用于外部排序。

## 9.6分配类排序

### 9.6.1多关键字排序

以一副扑克的排序为例,规定花色与面值顺序为花色:梅花<方块<红桃<黑桃
面值:A<2<3<…-<10<J<Q<K
并规定花色的优先级高于面值
**高位优先排序法**

先按花色分成有序的四类，然后再按面值对每一类从小到大排序。该方法称为"高位优先"排序法

**低位优先排序法**

分配与收集交替进行。首先按面值从小到大把牌摆成13叠(每叠4张牌），然后将每叠牌按面值的次序收集到一起,再对这些牌按花色摆成4叠,每叠有13张牌，最后把这4叠牌按花色的次序收集到一起

### 9.6.2链式基数排序

【算法思想】

按最低位的值对记录进行初步排序,在此基础上再按次低位的值进行进一步排序。依此类推,由低位到高位,根据关键字的某一位对所有记录进行排序，直至最高位。
数据类型定义

```c
/*有关数据结构定义(采用静态链表)*/
#define RADIX 10
#define KEY_SIZE 6
#define LIST_SIZE 20
typedef int KeyType;
typedef struct {
  KeyType keys [KEY_SIZE];/*子关键字数组*/
	OtherType other_data ;/*其它数据项*/
	int next;/*静态链域*/
}RecordType1 ;

typedef struct {
	RecordType1r[LIST_SIZE+1];/*r[0]为头结点*/
	int length;
	int keynum ;
}SLinkList;/*静态链表*/

typedef int PVector [RADIX];
```

![](https://p.ananas.chaoxing.com/star3/origin/dde29a76f7a88ab463e96569fbf62d6f.png?rw=894&rh=695&_fileSize=120123&_orientation=1)

![](https://p.ananas.chaoxing.com/star3/origin/4e16a54f4fe36142772390cbf426f656.png?rw=965&rh=711&_fileSize=129526&_orientation=1)

![](https://p.ananas.chaoxing.com/star3/origin/db048b5770570319b1e42d372f2d9368.png?rw=979&rh=720&_fileSize=138604&_orientation=1)

示例

【算法描述】

```c
void RadixSort (RecordTyper[,int length )
{
  n= length;
  for ( i=0 ; i<= n-1 ; ++i)r[i].next=i+1 ;
    r[n].next =0 ;
  d= keynum;
  for ( i =d-1 ; i>= 0; - -i )
    {
      Distribute(r, i, head, tail) ;
      Collect (r, head，tail)
    }
}/*RadixSort*/
```

【算法分析】

对于n个记录（每个记录含d个子关键字，每个子关键字的取值范围为RADIX个值）进行链式排序的时间复杂度为O ( d ( n +RADIX)） ,其中每一趟分配算法的时间复杂度为o (n)，每一趟收集算法的时间复杂度为O（RADIX），整个排序进行d趟分配和收集,所需辅助空间为2 XRADIX个队列指针，且相对于其它以顺序结构存储记录的排序方法,还增加了n个指针域空间。

### 9.6.3基数排序的顺序表实现

仿照稀疏矩阵的转置中的交换方法实现。如:关键字k1k2k3,先按k3扫描一遍,分别记下k3位为0的记录个数到为9的记录个数。形成两个计数数组num[10]和cpos[10]，对上例序列278，109，063，930，589，184，505，269，008，083中按k3位统计的结果如表所示:

|        | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| num[]  | 1    | 0    | 0    | 2    | 1    | 1    | 0    | 0    | 2    | 3    |
| cpos[] | 0    | 1    | 1    | 1    | 3    | 4    | 5    | 5    | 5    | 7    |

通过统计和确定位置,决定了第一次出现在k3位上值为i(O≤i≤9)的记录在排好序向量中的位置cpos[i]，之后,扫描待排序记录，根据其k3位的值i,找到其在排号序的向量中的相应位置，即可完成按k3位进行的排序。以此类推，再分别按k2和k1位进行统计、定位与置放,最终完成基数排序的全过程。

## 9.7各种排序方法的综合比较

### 性能比较

![img](https://p.ananas.chaoxing.com/star3/origin/0ec1933d6a922b89a302c08ea28f6957.png?rw=900&rh=447&_fileSize=106097&_orientation=1)

### 稳定性比较

![](https://p.ananas.chaoxing.com/star3/origin/87bba30160d9fc10e25bf910b6738d91.png?rw=952&rh=599&_fileSize=118658&_orientation=1)

### 结论

- 简单排序一般只用于n较小的情况。
  当序列中的记录"基本有序时，直接插入排序是最佳的排序方法，常与快速排序、归并排序等其它排序方法结合使用。
- 快速排序、堆排序和归并排序平均时间复杂度为O(n|ogn)
  就平均时间性能而言，快速排序是所有排序方法中最好的
  快速排序在最坏情况下的时间性能为0(n^2^)。
  堆排序和归并排序的最坏时间复杂度仍为0(n|ogn)，当n较大时，，归并排序的时间性能优于堆排序，但它所需的辅助空间最多
- 基数排序的时间复杂度可以写成O(d*n)。因此,它最适用于n值很大而关键字的位数d较小的序列。
- 基数排序是稳定的,除了简单选择排序,其它各种简单排序法也是稳定的。
  快速排序、堆排序、希尔排序等时间性能较好的排序方法,以及简单选择排序都是不稳定的。
- 可以将简单排序法与性能较好的排序方法结合使用。
  如:在快速排序中，当划分子区间的长度小于某值时，可以调用直接插入排序法;或者先将待排序序列划分成若干子序列,分别进行直接插入排序，然后再利用归并排序法，将有序子序列合并成一个完整的有序序列。

## 9.8总结与提高

### 9.8.1主要知识点

- 插入、交换、选择、归并、分配这5类内排序算法，均为基于比较的排序，即排序过程的实现主要靠关键字的关系大小比较。
  理解各类排序的基本方法非常重要。
- 熟练掌握三种简单排序方法（直接插入、冒泡排序、简单选择）的基本思想和算法描述,掌握这些排序法的特点和适用情况，并能应用分析。
  这些简单算法所需要的时间代价大多为0(n2）,但在某些特殊情况下可能取得很好的效果。
- 掌握三种改进排序方法(希尔排序、快速排序、堆排序）的基本思路及其特点和适用情况，并能根据特点给出应用分析。
  这些排序算法,平均情况下的时间复杂度为0 (nlog2n) 。
- 理解归并排序法的基本思想和算法描述。
  归并排序，固定需要与原始数据个数等量的辅助空间。
  归并排序方法多用于外排序。为了减少访问外存的次数,减少外设的台数和输入输出缓冲区的个数,并使主机和外设尽量并行工作，这外排序的讨论增加了难度。
- 掌握基数排序法基本思想和两种实现途径。
- 证明一种排序方法是稳定的,要从算法本身的步骤中加以证明。证明排序方法是不稳定的,只需给出一个反例说明。快速排序、堆排序、直接选择排序、希尔排序是不稳定的排序。

### 9.8.2典型题例

#### 例9.1排序方法选择

①设有10000个无序元素，仅要求找出前10个最小元素，在下列排序方法中（归并排序、基数排序、快速排序、堆排序、插入排序）哪一种方法最好，为什么
?
解:待排序元素10000，仅需找出前10个最小元素,因此并不需要整个排序;
选用堆排序中的一趟排序，即可求出最小值,仅需10次调用一趟排序，即可达到要求结果。而其他的归并排序、基数排序、快速排序、插入排序方法均要全部排好才可达到要求，因此选择堆排序最好。

②对长度为n的记录序列进行快速排序时,所需进行的比较次数依赖于这n个元素的初始排列。分析其最坏与最好情况，对n=7给出一个最好情况的初始排列实例。

解:快速排序算法是平均排序性能最好的算法之一。快速排序最坏情况是序列有序，每次以枢轴元素为界，序列分为两个子表，一个子表为空，另一个子表为n-1个元素，快速排序蜕变为冒泡排序。
快速排序最好情况是这样的排列，每次的枢轴元素放置的位置在表中间，正好能够将序列分为两个长度相当的子表，此时快速排序性能类同折半判定树的分析。其趟数为Llog~2~n] +1。

#### 例9.2荷兰国旗问题

方法一:采用简单选择排序思想

算法思想

假设这些条块颜色依次存放在L[0.. n-1]中，利用简单选择排序思想，首先从序列中选取所有的红色条块，依次放到序列的前面，然后再从剩余的序列中选取所有的白色条块，依次放到红色条块后面。这样经过两趟选择后，整个序列就按红、白、蓝有序。每一趟选择的时间复杂度为O(n)，整个过程的时间复杂度也为O(n)。

算法描述

```c
void Sort (int L，int n)
/*条块颜色依次存放在L[O..n-1]中，本算法利用简单选择排序思想，将整个序列按红、白、蓝进行排序。*/
{
  int i， j，x;
  i=O;/*i指向第一个红色条块应该放的位置*/
  for (j=i ; j<n; j++)/*j扫描所有尚未放置好的条块，寻找红色条块*/
  	if(LLj]==1)/*找到一个红色条块*/
  		{
  			if (j!=i)/*找到的红色条块不在下一个红色条块应该放的位置则换位*/
  				{
            x=L[j];
            L[j]=L[i];
            L[i]=x;
          }
  			i++;/*i指向下一个红色条块应该放的位置*/
  		}/*退出前面循环后，i指向第一个白色条块应该放的位置*/
  	for(j=i ;j<n; j++) /*j扫描所有尚未放置好的条块,寻找白色条块*/
  	if (LLj]==2)/*找到一个白色条块*/
      {
        if (j!=i)/*找到的白色条块不在下一个白色条块应该放的位置则换位*/
          {
            x=L[j];
            L[j]=L[i];
            L[i]=x;
          }
        i++;/*i指向下一个白色条块应该放的位置*/
      }
}
```



方法二:采用快速排序思想

算法思想

采用一个循环。具体方法是:设置3个整型变量r、w.b，其中r指向红色条块区的下一个单元，w指向白色条块区的下一个单元，b指向蓝色条块区的前一个单元。
开始时令r和w为0，b为n-1。w相当于快速排序中的low指针,b相当于快速排序中的high指针。
最终L[0..r-1]存放红色条块区，L[r. . w-1]存放白色条块区，L[w..n-1]存放蓝色条块区。

算法描述

```c
void Sort ( int L，int n)
/*条块颜色依次存放在L[O..n-1]中，本算法利用快速排序思想，将整个序列按红、白、蓝进行排序。*/
{
  int x;
  int r;/*r指向红色条块区的下一个单元（白色条块区的第一个单元）*/
  int w;/* w指向白色条块区的下一个单元（相当于快速排序中的Iow指针）*/
  int b;/* b指向蓝色区的前一个单元（相当于快速排序中的high指针）*/
  r=w=O ;/*相当于low=O*/
  b=n-1;/*相当于high=n-1 */
  while (w<=b)
    {
      x=L[w];
      if (x==1)/*L[w]是红色条块，并且在白色条块区的下一个单元*/
        {
          L[w]= L[r];/*L[r]是第一个白色条块，将其移到白色条块区最后*/
          w++;/*w指向白色条块区的下一个单元*/
          L[r]=x;/*将红色条块x放到红色条块区的下一个单元*/
          r++;
        }/*r指向红色条块区的下一个单元*/
      else if (x==2) /*L[w]是白色条块，且在白色条块区的下一个单元*/
        w++;
      /*w指向白色条块区的下一个单元*/
      else /*L[w]是蓝色条块*/
        {
          L[w]= L[b];/*b指向蓝色区的前一个单元，将L[b]与L[w]交换*/
          L[b]=x ; b--;}/*b指向蓝色条块区的前一个单元*/
        }
    }
}
```



#### 例9.3哈希排序

假设有300个记录,其关键字均为小于1000的正整数,并且互不相等。试设计一种排序方法,以尽可能少的比较次数和移动次数实现排序。
解:题中没有限制辅助空间,因此可以采用哈希表方法在0(n)时间复杂度内的实现辅助存放,由于是按地址与内容对应的存储,可通过按序将结果另行置入结果数组的方式实现排序。
实现步骤:
(1)设计辅助数组b[1..999]，每个元素存放一个记录，初始时全部置为空记录;
(2)逐一扫描记录序列r[1..300]的每一个记录,若记录r[i]的关键字为K,则将其放到b[K]中;
(3)再依次将b[1..999]中的非空记录逐一按顺序存于r [1..300]中。

---

# 第10章 外部排序

## 10.1外存信息的特性

### 10.1.1磁带存储器

#### 磁带存储器的特性

磁带存储器是一种典型的顺序存取设备。
磁带的存取时间主要用在定位上，读/写头与所需信息的距离越远，定位时间就越长。
当磁带转到信息所在位置上时，才开始真正读写数据。磁带的读写速度由走带速度和存储密度所决定。
磁带上的信息分为若干记录块，之间有一定的间隙。磁带存取比较慢，而且存储位置的顺序性很强。

#### 分页块存储方法

为了减少存储空间的浪费，通常采用把若干个记录组合成页块进行存储的办法，将记录间的间隙变成页块间的间隙。
一般情况下，可以把记录称为逻辑记录，而把逻辑记录组合成的页块称为物理记录。

### 10.1.2磁盘存储器

#### 磁盘存储器的特性

磁盘存储器是一种直接存取设备。磁盘的存取时间主要取决于寻查时间和等待时间。

#### 分页块存储方法

为了减少访问外存的次数，一般采用把记录组合成页块的方式来进行内外存数据的交换。一个页块（简称块）是磁盘上的一个物理记录，通常可以容纳多个逻辑记录，内存中设置的缓冲区应该与页块的大小相等。

## 10.2外排序的基本方法

### 10.2.1磁盘排序

#### 排序阶段

外排序分两个阶段:

(1）生成初始顺串:
把文件逐段输入内存，用内排序方法进行排序，生成顺串（归并段），然后再输出到外存;
(2）归并:
对顺串反复进行归并，直至变成一个顺串。

#### 归并方法

多路归并方法1:胜方树

多路归并方法2:败方树

#### 二路归并法

二路归并法

输入缓冲区:2个页块输出缓冲区:1个页块
两个顺串的当前页块分别读入到两个输入缓冲区中，进行归并后送入输出缓冲
输出缓冲区满:写回磁盘;
输入缓冲区空:读入顺串中下一个页块。

归并过程

![](https://p.ananas.chaoxing.com/star3/origin/4c9f0d3d175bb77e14e70625ca6ba42a.png?rw=1370&rh=619&_fileSize=76494&_orientation=1)

#### 胜方树

**胜方树**

胜方树:一种完全二叉树:
叶结点:各顺串的当前记录，
非叶结点:代表其两个子结点中较小的一个。
根结点:树中的最小结点，即下一个要输出的记录结点。

特点

可比作淘汰赛，其中获胜者便是那个具有较小关键字值的记录。
每场比赛的获胜者进入下一轮比赛，而根结点则代表全胜者。

图示

![](https://p.ananas.chaoxing.com/star3/origin/993698a3459f57709c086c92f003cab6.png?rw=1036&rh=881&_fileSize=119325&_orientation=1)

重构方法

根结点记录输出后，顺串中下一个记录成为当前记录，此时需要重构胜方树。
重构方法:
新结点与其兄弟结点进行比较，较小的关键字值写到父结点,此过程一直进行到根结点。



重建胜方树

当某个顺串的记录取尽时，把一个“无穷大”关键字值写到对应的叶结点中
当全部顺串都取尽时，再把下一组顺串读入，重新建立胜方树。



败方树

——每个非叶结点均存放其两个子结点中的败方。建立过程:
1、从叶结点开始分别对每两个兄弟结点进行比较，败者存放在父结点中，
2、胜者继续参加下一轮的比较，
3、最终结果是每个“选手”都停在自己失败的“比赛场”上。
4、在根结点之上有一个附加结点，存放全局优胜者

![](https://p.ananas.chaoxing.com/star3/origin/65e83dc19d7c29281febd02f0249c9bb.png?rw=1081&rh=798&_fileSize=136276&_orientation=1)

输出全局优胜者后，需要修改败方树。修改过程:
将新进入树的叶结点与父结点进行比较，大的存放在父结点
小的与上一级父结点再进行比较，直到根,最后把新的全局优胜者存放到附加结点。



置换选择顺序

假设输入文件FI是待排序文件，输出文件FO存放初始顺串，WA是可以容纳m个记录的内存工作区，则置换选择排序的基本过程为:
1．从FI输入m个记录到内存工作区 WA;
2．从WA中选出关键字最小的记录 Min，其关键字为 MinKey;3．将Min输出到FO中去;
4．若FI不空，则从FI读入下一个记录，送到WA中;
5．从WA中所有关键字大于 MinKey的记录中，重新选出关键字最小的记录 Min，其关键字为MinKey;
6．重复(3）至)，直到在WA中选不出新的Min记录为止，此时已得到一个初始顺串，所以输出一个结束标志到FO中;
7．重复（2）至（6），直到WA为空。此时，FO中将顺次存放着所有初始顺串。

![](https://p.ananas.chaoxing.com/star3/origin/33a446352df536c300dc3aa65711fdbc.png?rw=1271&rh=776&_fileSize=106425&_orientation=1)



最佳归并树

##### 最佳归并树

如何构造带权路径长度最小的归并树
我们将具有n个叶结点、且带权路径长度最短的二叉树称为哈夫曼树。同理,
我们
将具有n个叶结点、且带权路径长度最短的k叉树也称为哈夫曼树，并且其构造算法也是类似的，即优先选用权值小的结点。



##### 3路平衡归并树

![](https://p.ananas.chaoxing.com/star3/origin/0aaedd17560824ee04c98f8894da9b9b.png?rw=1351&rh=729&_fileSize=83182&_orientation=1)



##### 平衡最佳归并树的构造算法

我们将具有n个叶结点、且带权路径长度最短的k叉树也称为哈夫曼树，并且其构造算法也是类似的，即优先选用权值小的结点。

==未完待续==

### 10.2.2磁带排序

==结构混乱==

## 10.3总结与提高

### 10.3.1主要知识点

#### 基本概念

1. 外部排序:待排序的记录数n很大，内存容纳不下，必须借用外部存储器才能完成的排序过程。
2. 外存一般分为两类:顺序存取设备（如磁带存储器)、直接存取设备（如磁盘存储器）。
3. 磁带的存取时间主要用在定位上，读/写头与所需信息的距离越远，定位时间就越长。
4. 磁盘存储器（硬盘）特点:直接存取（随机存取)，高速。
5. 磁盘存储单位:盘片组，柱面，磁道，扇段。
6. 外存中把若干个记录（逻辑记录）组合成页块（物理记录）进行存储。页块（1KB~8KB)是内外存数据交换的基本单位:
   内存缓冲区:暂存一个页块的内容。

#### 外部排序的基本过程

- 生成初始顺串;
- 归并:对顺串反复进行归并，直至变成一个顺串

#### 初始顺串的生成方法

内部排序法。所生成顺串的大小正好等于一次能放入内存中的记录个数。
置换选择排序法。如果输入文件中的记录按其关键字随机排列，则所生成的初始顺串的平均长度为内存工作区大小的2倍

#### 归并方法

二路归并法
多路归并方法（1):胜方树   了解胜方树的结构特点和重构方法。
多路归并方法（2):败方树   了解败方树的结构特点和重构方法。

### 10.3.2典型题例

#### 最佳归并树

题例

已知有31个长度不等的初始归并段，其中8段长度为2，8段长度为3，7段长度为5，5段长度为12，3段长度为20（单位为物理块）。请设计一个5-路最佳归并方案，并计算归并时总的读/写外存次数。



分析

根据题目可知:31个初始归并段执行5-路归并。由于（31—1) MOD(5—1） = 2 >0，所以第一次归并（31一1)MOD (5一1) +1=3个长度最短的初始归并段，以后每一步都5个长度最短的初始归并段。

图示

![](https://p.ananas.chaoxing.com/star3/origin/7cc65cf46ecd166eb5491f7c3645691f.png?rw=1364&rh=483&_fileSize=37170&_orientation=1)
